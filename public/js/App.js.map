{"version":3,"sources":["webpack:///App.js","webpack:///webpack/bootstrap af9c5046cd45b9ec1fd0","webpack:///./node_modules/vue/dist/vue.js","webpack:///(webpack)/buildin/global.js","webpack:///./resources/assets/App.js","webpack:///./node_modules/timers-browserify/main.js","webpack:///./node_modules/setimmediate/setImmediate.js","webpack:///./node_modules/process/browser.js","webpack:///./resources/assets/js/components/snake/snake.js","webpack:///./resources/assets/js/components/snake/game.js","webpack:///./resources/assets/config.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","setImmediate","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","factory","define","undefined","isUndef","v","isDef","isTrue","isFalse","isPrimitive","value","isObject","toRawType","_toString","slice","isPlainObject","isRegExp","isValidArrayIndex","val","parseFloat","String","Math","floor","isFinite","isPromise","then","catch","toString","Array","isArray","JSON","stringify","toNumber","isNaN","makeMap","str","expectsLowerCase","map","create","list","split","length","toLowerCase","remove","arr","item","index","indexOf","splice","hasOwn","key","cached","fn","cache","polyfillBind","ctx","boundFn","a","arguments","apply","_length","nativeBind","bind","toArray","start","ret","extend","to","_from","toObject","res","noop","b","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","every","e","Date","getTime","keysA","keys","keysB","looseIndexOf","once","called","this","isReserved","charCodeAt","def","writable","parsePath","path","bailRE","test","segments","isNative","Ctor","pushTarget","target","targetStack","push","Dep","popTarget","pop","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","data","children","text","elm","context","componentOptions","asyncFactory","ns","isStatic","isComment","fnContext","fnOptions","fnScopeId","asyncMeta","isCloned","toggleObserving","shouldObserve","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","shallow","dep","getOwnPropertyDescriptor","setter","set","childOb","depend","dependArray","newVal","notify","warn","max","del","mergeData","from","toVal","fromVal","hasSymbol","Reflect","ownKeys","mergeDataOrFn","parentVal","childVal","vm","instanceData","defaultData","mergeHook","concat","dedupeHooks","hooks","mergeAssets","assertObjectType","checkComponents","options","components","validateComponentName","RegExp","unicodeRegExp","source","isBuiltInTag","config","isReservedTag","normalizeProps","props","camelize","type","normalizeInject","inject","normalized","normalizeDirectives","dirs","directives","def$$1","update","mergeOptions","parent","child","mergeField","strat","strats","defaultStrat","_base","extends","mixins","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","booleanIndex","getTypeIndex","Boolean","hyphenate","stringIndex","getPropDefaultValue","prevShouldObserve","assertProp","default","$options","_props","getType","required","valid","expectedTypes","assertedType","assertType","expectedType","getInvalidTypeMessage","validator","simpleCheckRE","t","match","isSameType","len","message","join","receivedType","expectedValue","styleValue","receivedValue","isExplicable","isBoolean","Number","some","elem","args","handleError","err","info","cur","$parent","errorCaptured","capture","globalHandleError","invokeWithErrorHandling","handler","_handled","errorHandler","logError","inBrowser","inWeex","console","error","flushCallbacks","pending","copies","callbacks","nextTick","cb","_resolve","timerFunc","Promise","resolve","traverse","_traverse","seenObjects","clear","seen","isA","isFrozen","depId","has","add","createFnInvoker","fns","invoker","arguments$1","updateListeners","on","oldOn","remove$$1","createOnceHandler","old","event","normalizeEvent","passive","params","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","merged","extractPropsFromVNodeData","attrs","altKey","keyInLowerCase","tip","formatComponentName","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","node","nestedIndex","lastIndex","last","shift","_isVList","initProvide","provide","_provided","initInjections","result","resolveInject","forEach","provideKey","provideDefault","resolveSlots","slots","slot","name$1","isWhitespace","normalizeScopedSlots","normalSlots","prevSlots","hasNormalSlots","isStable","$stable","$key","_normalized","emptyObject","$hasNormal","key$1","normalizeScopedSlot","key$2","proxyNormalSlot","proxy","renderList","render","next","done","renderSlot","fallback","bindObject","nodes","scopedSlotFn","$scopedSlots","$slots","$createElement","resolveFilter","identity","isKeyNotMatch","expect","actual","checkKeyCodes","eventKeyCode","builtInKeyCode","eventKeyName","builtInKeyName","mappedKeyCode","keyCodes","bindObjectProps","asProp","isSync","isReservedAttribute","mustUseProp","domProps","camelizedKey","hyphenatedKey","$event","renderStatic","isInFor","_staticTrees","tree","staticRenderFns","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","bindObjectListeners","existing","ours","resolveScopedSlots","hasDynamicKeys","contentHashKey","bindDynamicKeys","baseObj","values","prependModifier","symbol","installRenderHelpers","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","createEmptyVNode","_u","_g","_d","_p","FunctionalRenderContext","contextVm","this$1","_original","isCompiled","_compiled","needNormalization","listeners","injections","scopedSlots","_scopeId","_c","createElement","createFunctionalComponent","mergeProps","renderContext","cloneAndMarkFunctionalResult","vnodes","clone","devtoolsMeta","createComponent","baseCtor","cid","resolveAsyncComponent","createAsyncPlaceholder","resolveConstructorOptions","model","transformModel","functional","nativeOn","abstract","installComponentHooks","createComponentInstanceForVnode","_isComponent","_parentVnode","inlineTemplate","hooksToMerge","toMerge","componentVNodeHooks","_merged","mergeHook$1","f1","f2","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","is","SIMPLE_NORMALIZE","$vnode","getTagNamespace","parsePlatformTagName","pre","applyNS","registerDeepBindings","force","style","class","initRender","_vnode","parentVnode","_renderChildren","parentData","isUpdatingChildComponent","_parentListeners","ensureCtor","comp","base","toStringTag","errorComp","resolved","owner","currentRenderingInstance","owners","loading","loadingComp","sync","timerLoading","timerTimeout","$on","forceRender","renderCompleted","$forceUpdate","clearTimeout","reject","reason","component","delay","setTimeout","timeout","isAsyncPlaceholder","getFirstComponentChild","initEvents","_events","_hasHookEvent","updateComponentListeners","remove$1","$off","_target","onceHandler","oldListeners","setActiveInstance","prevActiveInstance","activeInstance","initLifecycle","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","template","charAt","callHook","updateComponent","performance","mark","_name","_uid","startTag","endTag","_render","measure","_update","Watcher","before","updateChildComponent","renderChildren","newScopedSlots","oldScopedSlots","hasDynamicScopedSlot","needsForceUpdate","$attrs","$listeners","propKeys","_propKeys","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","j","$emit","resetSchedulerState","queue","activatedChildren","circular","waiting","flushing","flushSchedulerQueue","currentFlushTimestamp","getNow","watcher","sort","run","MAX_UPDATE_COUNT","user","expression","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","devtools","emit","queueActivatedComponent","queueWatcher","async","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","methods","initMethods","initData","_data","computed","initComputed","watch","nativeWatch","initWatch","propsOptions","isRoot","isReservedAttr","getData","watchers","_computedWatchers","isSSR","userDef","computedWatcherOptions","$data","defineComputed","shouldCache","createComputedGetter","createGetterInvoker","dirty","evaluate","createWatcher","expOrFn","$watch","initInternalComponent","vnodeComponentOptions","_componentTag","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","modified","latest","sealed","sealedOptions","Vue","_init","initUse","use","plugin","installedPlugins","_installedPlugins","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","keepAliveInstance","filter","cachedNode","pruneCacheEntry","current","cached$$1","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","isSVG","isUnknownElement","unknownElementCache","document","window","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","setStyleScope","scopeId","registerRef","isRemoval","ref","refs","refInFor","sameVnode","sameInputType","typeA","typeB","isTextInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","oldArg","arg","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","updateAttrs","inheritAttrs","oldAttrs","setAttr","isIE","isEdge","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","baseSetAttr","isBooleanAttr","isFalsyAttrValue","convertEnumeratedValue","setAttributeNS","isIE9","__ieph","blocker","stopImmediatePropagation","removeEventListener","addEventListener","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","prev","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","validDivisionCharRE","wrapFilter","baseWarn","msg","range","pluckModuleFunction","_","addProp","dynamic","rangeSetItem","plain","addAttr","dynamicAttrs","addRawAttr","attrsMap","attrsList","addDirective","isDynamicArg","prependModifierMarker","addHandler","important","prevent","right","middle","events","native","nativeEvents","newHandler","getRawBindingAttr","rawAttrsMap","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","removeFromMap","getAndRemoveAttrByRegex","attr","end","genComponentModel","number","valueExpression","assignment","genAssignmentCode","parseModel","lastIndexOf","index$1","expressionPos","expressionEndPos","eof","chr","isStringStart","parseString","parseBracket","inBracket","stringQuote","_warn","warn$1","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","selectedVal","code","value$1","typeBinding","binding","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","CHECKBOX_RADIO_TOKEN","change","createOnceHandler$1","target$1","remove$2","add$1","useMicrotaskFix","attachedTimestamp","original","_wrapper","currentTarget","timeStamp","ownerDocument","supportsPassive","updateDOMListeners","updateDOMProps","oldProps","childNodes","_value","strCur","shouldUpdateValue","innerHTML","svgContainer","svg","firstChild","checkVal","composing","isNotInFocusAndDirty","isDirtyWithModifiers","notInFocus","activeElement","_vModifiers","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","classList","whitespaceRE","getAttribute","removeClass","tar","replace","resolveTransition","css","autoCssTransition","nextFrame","raf","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","checkDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","actuallySetSelected","isMultiple","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","placeholder","h","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokenValue","tokens","rawTokens","exec","@binding","transformNode","classBinding","genData","transformNode$1","styleBinding","genData$1","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","html","advance","substring","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","endTagLength","stackedTag","reStackedTag","reCache","rest$1","all","shouldIgnoreFirstNewline","chars","textEnd","comment","commentEnd","shouldKeepComment","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","startTagClose","dynamicArgAttribute","attribute","unarySlash","isNonPhrasingTag","unary","shouldDecodeNewlinesForHref","outputSourceRange","rest","createASTElement","makeAttrsMap","parse","warnOnce","warned","warn$2","closeElement","element","trimEndingWhitespace","inVPre","processed","processElement","root","if","elseif","else","checkRootConstraints","addIfCondition","block","currentParent","forbidden","processIfConditions","slotScope","slotTarget","platformIsPreTag","inPre","postTransforms","lastNode","isPreTag","platformMustUseProp","platformGetTagNamespace","maybeComponent","transforms","preTransforms","preserveWhitespace","whitespaceOption","whitespace","comments","start$1","guardIESVGBug","reduce","cumulated","invalidAttributeRE","isForbiddenTag","processPre","processRawAttrs","processFor","processIf","processOnce","end$1","isTextTag","decodeHTMLCached","lineBreakRE","whitespaceRE$1","processKey","processRef","processSlotContent","processSlotOutlet","processComponent","processAttrs","for","iterator2","iterator1","checkInFor","parseFor","inMatch","forAliasRE","alias","stripParensRE","iteratorMatch","forIteratorRE","findPrevElement","condition","ifConditions","slotTargetDynamic","slotBinding","slotRE","getSlotName","emptySlotScopeToken","slotBinding$1","ref$1","dynamic$1","slotContainer","dynamicArgRE","slotName","syncGen","isDynamic","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","checkForAliasModel","ieNSBug","ieNSPrefix","_el","preTransformNode","ifCondition","ifConditionExtra","hasElse","elseIfCondition","branch0","cloneASTElement","branch1","branch2","optimize","isStaticKey","genStaticKeysCached","staticKeys","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","i$1","l$1","staticInFor","staticRoot","isDirectChildOfTemplateFor","genHandlers","prefix","staticHandlers","dynamicHandlers","handlerCode","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","isFunctionInvocation","fnInvokeRE","genModifierCode","modifierCode","genGuard","keyModifier","genKeyFilter","genFilterCode","keyVal","parseInt","keyCode","keyName","keyNames","wrapListeners","bind$1","wrapData","generate","ast","state","CodegenState","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData$2","genChildren","originalPreState","onceId","altGen","altEmpty","genIfConditions","conditions","genTernaryExp","altHelper","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","inlineRenderFns","containsSlotChild","needsKey","generatedSlots","genScopedSlot","isLegacySyntax","reverseProxy","checkSkip","altGenElement","altGenNode","el$1","normalizationType$1","getNormalizationType","genNode","needsNormalization","genComment","genText","transformSpecialNewlines","bind$$1","componentName","staticProps","dynamicProps","detectErrors","checkNode","checkFor","checkEvent","checkExpression","stipped","stripStringRE","keywordMatch","unaryOperatorsRE","checkIdentifier","ident","Function","prohibitedKeywordRE","generateCodeFrame","lines","count","repeat$1","lineLength","pad","length$1","min","createFunction","errors","createCompileToFunctionFn","compile","warn$$1","compiled","tips","fnGenErrors","getShouldDecode","href","div","getOuterHTML","outerHTML","container","cloneNode","freeze","camelizeRE","toUpperCase","hyphenateRE","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","warnHandler","ignoredElements","_lifecycleHooks","hasProto","WXEnvironment","platform","weexPlatform","UA","navigator","userAgent","isIOS","isFF","_isServer","_Set","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Set","generateComponentTrace","hasConsole","classifyRE","classify","trace","includeFile","file","__file","repeat","currentRecursiveSequence","uid","subs","addSub","sub","removeSub","addDep","raw","prototypeAccessors","defineProperties","arrayProto","arrayMethods","method","observeArray","arrayKeys","getOwnPropertyNames","walk","items","isUsingMicroTask","MutationObserver","counter","observer","textNode","characterData","perf","clearMarks","clearMeasures","initProxy","allowedGlobals","warnNonPresent","warnReservedPrefix","hasProxy","Proxy","isBuiltInModifier","hasHandler","isAllowed","getHandler","_withStripped","once$$1","init","keepAlive","mountedNode","prepatch","$mount","insert","destroy","now","uid$2","isRenderWatcher","deep","active","deps","newDeps","depIds","newDepIds","cleanupDeps","tmp","teardown","uid$3","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","$once","cbs","lowerCaseEvent","prevEl","prevVnode","restoreActiveInstance","__patch__","__vue__","$nextTick","renderError","patternTypes","KeepAlive","include","exclude","created","destroyed","mounted","builtInComponents","configDef","util","defineReactive","delete","observable","ssrContext","version","emptyStyle","acceptValue","isValidContentEditableValue","math","isHTMLTag","nodeOps","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalizedName","normalize","vendorNames","capName","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","isUnknownElement$$1","ignore","createElm","insertedVnodeQueue","parentElm","refElm","nested","ownerArray","creatingElmInVPre","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ref$$1","checkDuplicateKeys","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","vnodeToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","findIdxInOld","seenKeys","hydrate","postpatch","invokeInsertHook","initial","assertNodeMatch","hasChildNodes","hydrationBailed","childrenMatch","fullInvoke","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","patchable","i$2","vmodel","directive","_vOptions","prevOptions","curOptions","transition$$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","isNotTextNode","isVShowDirective","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","beforeMount","kept","prevChildren","rawChildren","transitionData","removed","c$1","updated","hasMove","_reflow","body","offsetHeight","propertyName","_hasMove","platformComponents","decoder","regexEscapeRE","open","close","klass$1","style$1","he","decode","ncname","qnameCapture","&lt;","&gt;","&quot;","&amp;","&#10;","&#9;","&#39;","isIgnoreNewlineTag","model$1","modules$1","directives$1","baseOptions","esc","tab","space","up","down","stop","self","ctrl","alt","meta","baseDirectives","cloak","createCompiler","baseCompile","finalOptions","leadingSpaceLength","compileToFunctions","idToTemplate","mount","documentElement","g","eval","_interopRequireDefault","_vue","_vue2","_snake","Timeout","clearFn","_id","_clearFn","scope","setInterval","clearInterval","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","_onTimeout","require","clearImmediate","process","task","tasksByHandle","nextHandle","registerImmediate","handle","runIfPresent","currentlyRunningATask","doc","attachTo","getPrototypeOf","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","messagePrefix","random","onGlobalMessage","attachEvent","MessageChannel","channel","port1","port2","script","onreadystatechange","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","Item","array","title","browser","argv","versions","addListener","off","removeListener","removeAllListeners","prependListener","prependOnceListener","cwd","chdir","umask","_game","snake","play","score","playToggle","onPlayChange","onScoreChange","_config","_config2","game","tail","directionX","directionY","apple","posX","posY","timer","boxCountX","canvas","width","gridSize","boxCountY","height","headOfSnake","assign","endOfSnake","createApple","createSnake","draw","onKeyDown","snake.play","loop","score.count","_this","calc","speed","isEatingAppleSnake","scoreChange","addTailSnake","isBumpSnake","gameReset","getContext","drawCanvas","drawApple","drawSnake","fillStyle","fillRect","color","gridSpace","position","initialTailSize","gamePlay","gamePause","snakeRotateLeft","snakeRotateUp","snakeRotateRight","snakeRotateDown","gamePlayToggle"],"mappings":"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","file":"App.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (global = global || self, global.Vue = factory());\n})(undefined, function () {\n  'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' ||\n    // $flow-disable-line\n    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject(obj) {\n    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n\n  function isPromise(val) {\n    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString(val) {\n    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to;\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject(arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res;\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop(a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function no(a, b, c) {\n    return false;\n  };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function identity(_) {\n    return _;\n  };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime();\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];\n\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Define a property.\n   */\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp(\"[^\" + unicodeRegExp.source + \".$_\\\\d]\");\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n        obj = obj[segments[i]];\n      }\n      return obj;\n    };\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = {}.watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function isServerRendering() {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer;\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n  var formatComponentName = noop;\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function classify(str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function warn(msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function tip(msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function formatComponentName(vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function repeat(str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n        if (n > 1) {\n          str += str;\n        }\n        n >>= 1;\n      }\n      return res;\n    };\n\n    generateComponentTrace = function generateComponentTrace(vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) {\n        return a.id - b.id;\n      });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget() {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function createEmptyVNode(text) {\n    if (text === void 0) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned;\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) {\n        ob.observeArray(inserted);\n      }\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) {\n          return;\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set(target, key, val) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del(target, key) {\n    if (isUndef(target) || isPrimitive(target)) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n    var ob = target.__ob__;\n    if (target._isVue || ob && ob.vmCount) {\n      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n    if (!hasOwn(target, key)) {\n      return;\n    }\n    delete target[key];\n    if (!ob) {\n      return;\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n      return defaultStrat(parent, child);\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') {\n        continue;\n      }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n        return parentVal;\n      }\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook(parentVal, childVal) {\n    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n    return res ? dedupeHooks(res) : res;\n  }\n\n  function dedupeHooks(hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) {\n      extend(ret, childVal);\n    }\n    return ret;\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeRegExp.source + \"]*$\").test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'should conform to valid custom element name in html5 specification.');\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps(options, vm) {\n    var props = options.props;\n    if (!props) {\n      return;\n    }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : { type: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n    if (!inject) {\n      return;\n    }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  /*  */\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n    if (value == null && !prop.required) {\n      return;\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);\n      return;\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function getInvalidTypeMessage(name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ');\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message;\n  }\n\n  function styleValue(value, type) {\n    if (type === 'String') {\n      return \"\\\"\" + value + \"\\\"\";\n    } else if (type === 'Number') {\n      return \"\" + Number(value);\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  function isExplicable(value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) {\n      return value.toLowerCase() === elem;\n    });\n  }\n\n  function isBoolean() {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }return args.some(function (elem) {\n      return elem.toLowerCase() === 'boolean';\n    });\n  }\n\n  /*  */\n\n  function handleError(err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while (cur = cur.$parent) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) {\n                  return;\n                }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling(handler, context, args, vm, info) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) {\n          return handleError(e, vm, info + \" (Promise/async)\");\n        });\n        // issue #9511\n        // avoid catch triggering multiple times when nested calls\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res;\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function timerFunc() {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function timerFunc() {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function timerFunc() {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function mark(tag) {\n        return perf.mark(tag);\n      };\n      measure = function measure(name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function warnNonPresent(target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var warnReservedPrefix = function warnReservedPrefix(target, key) {\n      warn(\"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" + 'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);\n        if (!has && !isAllowed) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n        return has || !isAllowed;\n      }\n    };\n\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) {\n            warnReservedPrefix(target, key);\n          } else {\n            warnNonPresent(target, key);\n          }\n        }\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse(val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return;\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns, vm) {\n    function invoker() {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\n      }\n    }\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return;\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n    return children;\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i);\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') {\n          continue;\n        }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n      return result;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots(children, context) {\n    if (!children || !children.length) {\n      return {};\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n\n  /*  */\n\n  function normalizeScopedSlots(slots, normalSlots, prevSlots) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized;\n    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots;\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      slots._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res;\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function normalized() {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && !Array.isArray(res) ? [res] // single vnode\n      : normalizeChildren(res);\n      return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658\n      ) ? undefined : res;\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized;\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () {\n      return slots[key];\n    };\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    ret._isVList = true;\n    return ret;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n\n  /*  */\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function loop(key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) {\n          loop(key);\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree;\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data;\n  }\n\n  /*  */\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys, contentHashKey) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      res.$key = contentHashKey;\n    }\n    return res;\n  }\n\n  /*  */\n\n  function bindDynamicKeys(baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\"Invalid value for dynamic directive argument (expected string or null): \" + key, this);\n      }\n    }\n    return baseObj;\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier(value, symbol) {\n    return typeof value === 'string' ? symbol + value : value;\n  }\n\n  /*  */\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));\n      }\n      return this$1.$slots;\n    };\n\n    Object.defineProperty(this, 'scopedSlots', {\n      enumerable: true,\n      get: function get() {\n        return normalizeScopedSlots(data.scopedSlots, this.slots());\n      }\n    });\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1(f1, f2) {\n    var merged = function merged(a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged;\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n\n  /*  */\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    var owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null;owner.$on('hook:destroyed', function () {\n        return remove(owners, owner);\n      });\n\n      var forceRender = function forceRender(renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          owners[i].$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n\n  /*  */\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler(event, fn) {\n    var _target = target;\n    return function onceHandler() {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    };\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm;\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm;\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm;\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    };\n  }\n\n  function initLifecycle(vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function updateComponent() {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function updateComponent() {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before() {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key);\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    hasDynamicScopedSlot);\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n    if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function getNow() {\n        return performance.now();\n      };\n    }\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue() {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return;\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n    this.value = this.lazy ? undefined : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value;\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend() {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown() {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function loop(key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) {\n      loop(key);\n    }toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      }\n    };\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter() {\n      return fn.call(this, this);\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\"Method \\\"\" + key + \"\\\" has type \\\"\" + _typeof(methods[key]) + \"\\\" in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () {\n      return this._data;\n    };\n    var propsDef = {};\n    propsDef.get = function () {\n      return this._props;\n    };\n    {\n      dataDef.set = function () {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, \"callback for immediate watcher \\\"\" + watcher.expression + \"\\\"\");\n        }\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n        modified[key] = latest[key];\n      }\n    }\n    return modified;\n  }\n\n  function Vue(options) {\n    if (!(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n\n  /*  */\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n\n  /*  */\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed() {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted() {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n        // not included\n        include && (!name || !matches(include, name)) ||\n        // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || slot && slot[0];\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () {\n      return config;\n    };\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj;\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.10';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function mustUseProp(tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function convertEnumeratedValue(key, value) {\n    return isFalsyAttrValue(value) || value === 'false' ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';\n  };\n\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function isXlink(name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function getXlinkProp(name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function isFalsyAttrValue(val) {\n    return val == null || val === false;\n  };\n\n  /*  */\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n        res += stringified;\n      }\n    }\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n        res += key;\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function isPreTag(tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function isReservedTag(tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n    if (isReservedTag(tag)) {\n      return false;\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n      return selected;\n    } else {\n      return el;\n    }\n  }\n\n  /*  */\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm;\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove$$1() {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope(vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return;\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true /* hydrating */);\n        }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false;\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(vnode, insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function callInsert() {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {\n        var blocker = function blocker(e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x60:\n            inTemplateString = true;break; // `\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0;\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') {\n              break;\n            }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n\n  /*  */\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn(msg, range) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value, range, dynamic) {\n    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr(el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker(symbol, name, dynamic) {\n    return dynamic ? \"_p(\" + name + \",\\\"\" + symbol + \"\\\")\" : symbol + name; // mark the event as captured\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.', range);\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr(el, name) {\n    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val;\n  }\n\n  function getAndRemoveAttrByRegex(el, name) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr;\n      }\n    }\n  }\n\n  function rangeSetItem(item, range) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item;\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: JSON.stringify(value),\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\n    }\n\n    // ensure runtime directive metadata\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1(event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1(name, handler, capture, passive) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document) {\n          return original.apply(this, arguments);\n        }\n      };\n    }\n    target$1.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n  }\n\n  function remove$2(name, handler, capture, _target) {\n    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n        if (cur === oldProps[key]) {\n          continue;\n        }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n    return bindingStyle;\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res;\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function setProp(el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition(def$$1) {\n    if (!def$$1) {\n      return;\n    }\n    /* istanbul ignore else */\n    if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res;\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) {\n      return cb();\n    }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function end() {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function onEnd(e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n  }\n\n  /*  */\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return;\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return;\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) {\n        return;\n      }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var isNotTextNode = function isNotTextNode(c) {\n    return c.tag || isAsyncPlaceholder(c);\n  };\n\n  var isVShowDirective = function isVShowDirective(d) {\n    return d.name === 'show';\n  };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render(h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return;\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return;\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n          var delayedLeave;\n          var performLeave = function performLeave() {\n            delayedLeave();\n          };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount() {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (e && e.target !== el) {\n              return;\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove;\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n      if (config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return;\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while (match = tagRE.exec(text)) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n\n  /*  */\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeRegExp.source + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue;\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) {\n              break;\n            }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\", { start: index + html.length });\n        }\n        break;\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) {\n        start = index;\n      }\n      if (end == null) {\n        end = index;\n      }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\", { start: stack[i].start, end: stack[i].end });\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    };\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function maybeComponent(el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement(element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\", { start: element.start });\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) {\n        return !c.slotScope;\n      });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace(el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints(el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.', { start: el.start });\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start(tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated;\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\"Invalid dynamic argument expression: attribute names cannot contain \" + \"spaces, quotes, <, >, / or =.\", {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              });\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.', { start: element.start });\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end(tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars(text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.', { start: start });\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\", { start: start });\n            }\n          }\n          return;\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment(text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element;\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\"Do not use v-for index as key on <transition-group> children, \" + \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp, el.rawAttrsMap['v-for']);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      return;\n    }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\", children[i]);\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent(el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\"<template v-slot> can only appear at the root level inside \" + \"the receiving the component\", el);\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\"v-slot can only be used on components or <template>.\", slotBinding$1);\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\"Unexpected mixed usage of different slot syntaxes.\", el);\n            }\n            if (el.scopedSlots) {\n              warn$2(\"To avoid scope ambiguity, the default slot should also use \" + \"<template> syntax when there are other named slots.\", slotBinding$1);\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true;\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName(binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\"v-slot shorthand syntax requires a slot name.\", binding);\n      }\n    }\n    return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true\n      // static name\n    } : { name: \"\\\"\" + name + \"\\\"\", dynamic: false };\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (value.trim().length === 0) {\n            warn$2(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\");\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(el, \"update:\" + camelize(name), syncGen, null, false, warn$2, list[i]);\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(el, \"update:\" + hyphenate(name), syncGen, null, false, warn$2, list[i]);\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(el, \"\\\"update:\\\"+(\" + name + \")\", syncGen, null, false, warn$2, list[i], true // dynamic\n                );\n              }\n            }\n          }\n          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n      parent = parent.parent;\n    }\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map;\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug(attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [klass$1, style$1, model$1];\n\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  /*  */\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\", dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false;\n      }\n      if (node.for) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function genGuard(condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + staticHandlers.slice(0, -1) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + dynamicHandlers.slice(0, -1) + \"])\";\n    } else {\n      return prefix + staticHandlers;\n    }\n  }\n\n  function genHandler(handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n      return \"function($event){\" + (isFunctionInvocation ? \"return \" + handler.value : handler.value) + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : isFunctionInvocation ? \"return \" + handler.value : handler.value;\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" + keys.map(genFilterCode).join('&&') + \")return null;\"\n    );\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n\n  /*  */\n\n  function on(el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n\n  /*  */\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) {\n      return !!el.component || !isReservedTag(el.tag);\n    };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || el.pre && state.maybeComponent(el)) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code;\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic(el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    state.pre = originalPreState;\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  }\n\n  // v-once\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\n        return genElement(el, state);\n      }\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) {\n      data += dirs + ',';\n    }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + genProps(el.attrs) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + genProps(el.props) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += genHandlers(el.events, false) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += genScopedSlots(el, el.scopedSlots, state) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + el.tag + \"\\\",\" + genProps(el.dynamicAttrs) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n    if (!dirs) {\n      return;\n    }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\" + (dir.isDynamicArg ? dir.arg : \"\\\"\" + dir.arg + \"\\\"\") : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn('Inline-template components must have exactly one child element.', { start: el.start });\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(el, slots, state) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      ;\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {\n          needsForceUpdate = true;\n          break;\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots).map(function (key) {\n      return genScopedSlot(slots[key], state);\n    }).join(',');\n\n    return \"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? \",null,false,\" + hash(generatedSlots) : \"\") + \")\";\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while (i) {\n      hash = hash * 33 ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0;\n  }\n\n  function containsSlotChild(el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true;\n      }\n      return el.children.some(containsSlotChild);\n    }\n    return false;\n  }\n\n  function genScopedSlot(el, state) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\");\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot);\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" + \"return \" + (el.tag === 'template' ? el.if && isLegacySyntax ? \"(\" + el.if + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return \"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\";\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? \",1\" : \",0\" : \"\";\n        return \"\" + (altGenElement || genElement)(el$1, state) + normalizationType;\n      }\n      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType$1 ? \",\" + normalizationType$1 : '');\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue;\n      }\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {\n      return {\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      };\n    })) : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')';\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += prop.name + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + prop.name + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + staticProps.slice(0, -1) + \"}\";\n    if (dynamicProps) {\n      return \"_d(\" + staticProps + \",[\" + dynamicProps.slice(0, -1) + \"])\";\n    } else {\n      return staticProps;\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n\n  /*  */\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors(ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode(node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent(exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim(), range);\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor(node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier(ident, type, text, warn, range) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        warn(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim(), range);\n      }\n    }\n  }\n\n  function checkExpression(exp, text, warn, range) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim(), range);\n      } else {\n        warn(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\", range);\n      }\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame(source, start, end) {\n    if (start === void 0) start = 0;\n    if (end === void 0) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) {\n            continue;\n          }\n          res.push(\"\" + (j + 1) + repeat$1(\" \", 3 - String(j + 1).length) + \"|  \" + lines[j]);\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break;\n      }\n    }\n    return res.join('\\n');\n  }\n\n  function repeat$1(str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) {\n        // eslint-disable-line\n        if (n & 1) {\n          result += str;\n        }\n        n >>>= 1;\n        if (n <= 0) {\n          break;\n        }\n        str += str;\n      }\n    }\n    return result;\n  }\n\n  /*  */\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n      if (cache[key]) {\n        return cache[key];\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\"Error compiling template:\\n\\n\" + e.msg + \"\\n\\n\" + generateCodeFrame(template, e.start, e.end), vm);\n            });\n          } else {\n            warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n              return \"- \" + e;\n            }).join('\\n') + '\\n', vm);\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) {\n              return tip(e.msg, vm);\n            });\n          } else {\n            compiled.tips.forEach(function (msg) {\n              return tip(msg, vm);\n            });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n\n      return cache[key] = res;\n    };\n  }\n\n  /*  */\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function warn(msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function warn(msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating);\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(4).setImmediate))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _snake = __webpack_require__(7);\n\nvar _snake2 = _interopRequireDefault(_snake);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar App = new _vue2.default({\n    el: '#app',\n    data: {}\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scope = typeof global !== \"undefined\" && global || typeof self !== \"undefined\" && self || window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function () {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function () {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout = exports.clearInterval = function (timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function () {};\nTimeout.prototype.close = function () {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function (item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function (item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function (item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout) item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(5);\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = typeof self !== \"undefined\" && self.setImmediate || typeof global !== \"undefined\" && global.setImmediate || undefined && undefined.setImmediate;\nexports.clearImmediate = typeof self !== \"undefined\" && self.clearImmediate || typeof global !== \"undefined\" && global.clearImmediate || undefined && undefined.clearImmediate;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global, process) {\n\n(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n        // Callback can either be a function or a string\n        if (typeof callback !== \"function\") {\n            callback = new Function(\"\" + callback);\n        }\n        // Copy function arguments\n        var args = new Array(arguments.length - 1);\n        for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 1];\n        }\n        // Store and register the task\n        var task = { callback: callback, args: args };\n        tasksByHandle[nextHandle] = task;\n        registerImmediate(nextHandle);\n        return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n            case 0:\n                callback();\n                break;\n            case 1:\n                callback(args[0]);\n                break;\n            case 2:\n                callback(args[0], args[1]);\n                break;\n            case 3:\n                callback(args[0], args[1], args[2]);\n                break;\n            default:\n                callback.apply(undefined, args);\n                break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            process.nextTick(function () {\n                runIfPresent(handle);\n            });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function registerImmediate(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function registerImmediate(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function registerImmediate(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function registerImmediate(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(typeof self === \"undefined\" ? typeof global === \"undefined\" ? undefined : global : self);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(6)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n})();\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e) {\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while (len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n    return [];\n};\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n    return '/';\n};\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function () {\n    return 0;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _game = __webpack_require__(8);\n\nvar _game2 = _interopRequireDefault(_game);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar snake = _vue2.default.component('snake', {\n    data: function data() {\n        return {\n            play: false,\n            score: 0\n        };\n    },\n    methods: {\n        playToggle: function playToggle() {\n            this.play = !this.play;\n        },\n        onPlayChange: function onPlayChange(val) {\n            this.play = val;\n        },\n        onScoreChange: function onScoreChange(val) {\n            this.score = val;\n        }\n    },\n    template: '\\n        <div>\\n            <div class=\"snake-container\">\\n                <div class=\"snake\">\\n                    <div class=\"top-bar flex align-vertical-center align-horizontal-space-between\">\\n                        <div class=\"score\">\\n                            Score: {{score}}\\n                        </div>\\n                        <div class=\"butons\">\\n                            <button v-on:click=\"playToggle\" v-bind:class=\"[\\'button\\',\\'small\\', play ? \\'pause-button\\' : \\'play-button\\']\">\\n                                <span v-if=\"play\">Pause</span>\\n                                <span v-else>Play</span>\\n                            </button>\\n                        </div>\\n                    </div>\\n                    <game v-bind:play=\"play\" v-on:onPlayChange=\"onPlayChange\" v-on:onScoreChange=\"onScoreChange\"></game>\\n                </div>\\n            </div>\\n        </div>\\n    '\n});\n\nexports.default = snake;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _vue = __webpack_require__(0);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _config = __webpack_require__(9);\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar game = _vue2.default.component('game', {\n    props: {\n        play: { type: Boolean }\n    },\n    data: function data() {\n        return {\n            snake: {\n                play: this.play,\n                tail: [],\n                directionX: 1,\n                directionY: 0\n            },\n            apple: {\n                posX: 0,\n                posY: 0\n            },\n            score: {\n                count: 0\n            },\n            timer: null\n        };\n    },\n    created: function created() {\n        this.boxCountX = _config2.default.canvas.width / _config2.default.canvas.gridSize;\n        this.boxCountY = _config2.default.canvas.height / _config2.default.canvas.gridSize;\n\n        this.headOfSnake = Object.assign({}, this.snake.tail[this.snake.tail.length - 1]);\n        this.endOfSnake = Object.assign({}, this.snake.tail[0]);\n    },\n    mounted: function mounted() {\n        this.createApple();\n        this.createSnake();\n        this.draw();\n        document.addEventListener('keydown', this.onKeyDown);\n    },\n\n    watch: {\n        play: function play() {\n            this.snake.play = this.play;\n        },\n\n        'snake.play': function snakePlay() {\n            this.$emit('onPlayChange', this.snake.play);\n            this.loop();\n        },\n        'score.count': function scoreCount() {\n            this.$emit('onScoreChange', this.score.count);\n        }\n    },\n    methods: {\n        loop: function loop() {\n            var _this = this;\n\n            clearInterval(this.timer);\n            if (!this.snake.play) {\n                return false;\n            }\n\n            this.timer = setInterval(function () {\n                _this.calc();\n                _this.draw();\n            }, _config2.default.snake.speed);\n        },\n        calc: function calc() {\n            this.headOfSnake = Object.assign({}, this.snake.tail[this.snake.tail.length - 1]);\n            this.endOfSnake = Object.assign({}, this.snake.tail[0]);\n\n            this.headOfSnake.posX += this.snake.directionX;\n            this.headOfSnake.posY += this.snake.directionY;\n\n            // Out of box control\n            if (this.headOfSnake.posX === this.boxCountX) {\n                this.headOfSnake.posX = 0;\n            } else if (this.headOfSnake.posX < 0) {\n                this.headOfSnake.posX = this.boxCountX - 1;\n            } else if (this.headOfSnake.posY === this.boxCountY) {\n                this.headOfSnake.posY = 0;\n            } else if (this.headOfSnake.posY < 0) {\n                this.headOfSnake.posY = this.boxCountY - 1;\n            }\n\n            if (this.isEatingAppleSnake()) {\n                this.scoreChange();\n                this.addTailSnake();\n                this.createApple();\n            }\n\n            if (this.isBumpSnake()) {\n                this.gameReset();\n                return;\n            }\n\n            this.snake.tail.push(this.headOfSnake);\n            this.snake.tail.shift();\n        },\n        draw: function draw() {\n            var canvas = this.$refs.canvas;\n            var context = canvas.getContext('2d');\n            this.drawCanvas(canvas, context);\n            this.drawApple(context);\n            this.drawSnake(context);\n        },\n        drawCanvas: function drawCanvas(canvas, context) {\n            canvas.width = _config2.default.canvas.width;\n            canvas.height = _config2.default.canvas.height;\n\n            context.fillStyle = 'black';\n            context.fillRect(0, 0, _config2.default.canvas.width, _config2.default.canvas.height);\n        },\n        createApple: function createApple() {\n            this.apple.posX = Math.floor(Math.random() * this.boxCountX);\n            this.apple.posY = Math.floor(Math.random() * this.boxCountY);\n        },\n        drawApple: function drawApple(context) {\n            context.fillStyle = _config2.default.apple.color;\n            context.fillRect(this.apple.posX * _config2.default.canvas.gridSize, this.apple.posY * _config2.default.canvas.gridSize, _config2.default.canvas.gridSize - _config2.default.canvas.gridSpace, _config2.default.canvas.gridSize - _config2.default.canvas.gridSpace);\n        },\n        createSnake: function createSnake() {\n            var position = Math.floor(Math.random() * (this.boxCountX - _config2.default.snake.initialTailSize * 3)) + _config2.default.snake.initialTailSize;\n            this.snake.tail = [];\n            for (var i = 0; i <= _config2.default.snake.initialTailSize; i++) {\n                this.snake.tail.push({\n                    posX: this.snake.directionX ? position + i : position,\n                    posY: this.snake.directionY ? position + i : position\n                });\n            }\n        },\n        addTailSnake: function addTailSnake() {\n            this.endOfSnake.posX += this.snake.directionX;\n            this.endOfSnake.posY += this.snake.directionY;\n            this.snake.tail.unshift(this.endOfSnake);\n        },\n        isEatingAppleSnake: function isEatingAppleSnake() {\n            if (this.headOfSnake.posX === this.apple.posX && this.headOfSnake.posY === this.apple.posY) {\n                return true;\n            }\n            return false;\n        },\n        isBumpSnake: function isBumpSnake() {\n            for (var i in this.snake.tail) {\n                if (this.snake.tail[i].posX === this.headOfSnake.posX && this.snake.tail[i].posY === this.headOfSnake.posY) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        drawSnake: function drawSnake(context) {\n            this.snake.tail.forEach(function (tail) {\n                context.fillStyle = _config2.default.snake.color;\n                context.fillRect(tail.posX * _config2.default.canvas.gridSize, tail.posY * _config2.default.canvas.gridSize, _config2.default.canvas.gridSize - _config2.default.canvas.gridSpace, _config2.default.canvas.gridSize - _config2.default.canvas.gridSpace);\n            });\n        },\n        gamePlay: function gamePlay() {\n            this.snake.play = true;\n        },\n        gamePause: function gamePause() {\n            this.snake.play = false;\n        },\n        gameReset: function gameReset() {\n            this.score.count = 0;\n            this.gamePause();\n            this.createSnake();\n            this.createApple();\n            this.draw();\n        },\n        scoreChange: function scoreChange() {\n            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n            this.score.count += count;\n        },\n        onKeyDown: function onKeyDown(e) {\n            // Direction keys\n            if (_config2.default.keys.left.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateLeft();\n            }\n            if (_config2.default.keys.up.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateUp();\n            }\n            if (_config2.default.keys.right.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateRight();\n            }\n            if (_config2.default.keys.down.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateDown();\n            }\n            // Play\n            if (_config2.default.keys.gamePlay.indexOf(e.keyCode) !== -1) {\n                this.gamePlay();\n            }\n            // Play Toggle\n            if (_config2.default.keys.gamePlayToggle.indexOf(e.keyCode) !== -1) {\n                this.snake.play ? this.gamePause() : this.gamePlay();\n            }\n        },\n        snakeRotateLeft: function snakeRotateLeft() {\n            if (this.snake.directionX !== 1) {\n                this.snake.directionX = -1;\n                this.snake.directionY = 0;\n            }\n        },\n        snakeRotateUp: function snakeRotateUp() {\n            if (this.snake.directionY !== 1) {\n                this.snake.directionY = -1;\n                this.snake.directionX = 0;\n            }\n        },\n        snakeRotateRight: function snakeRotateRight() {\n            if (this.snake.directionX !== -1) {\n                this.snake.directionX = 1;\n                this.snake.directionY = 0;\n            }\n        },\n        snakeRotateDown: function snakeRotateDown() {\n            if (this.snake.directionY !== -1) {\n                this.snake.directionY = 1;\n                this.snake.directionX = 0;\n            }\n        }\n    },\n    template: '\\n        <canvas ref=\"canvas\"></canvas>\\n    '\n});\n\nexports.default = game;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar config = {\n    canvas: {\n        width: 900,\n        height: 700,\n        gridSize: 20,\n        gridSpace: 2\n    },\n    snake: {\n        color: '#fff',\n        speed: 1000 / 15,\n        initialTailSize: 9\n    },\n    apple: {\n        color: 'red'\n    },\n    keys: {\n        left: [37, 65],\n        up: [38, 87],\n        right: [39, 68],\n        down: [40, 83],\n        get gamePlay() {\n            return [].concat(this.left, this.up, this.right, this.down);\n        },\n        gamePlayToggle: [32]\n    }\n};\n\nexports.default = config;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// App.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap af9c5046cd45b9ec1fd0","/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Vue = factory());\n}(this, function () { 'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef (v) {\n    return v === undefined || v === null\n  }\n\n  function isDef (v) {\n    return v !== undefined && v !== null\n  }\n\n  function isTrue (v) {\n    return v === true\n  }\n\n  function isFalse (v) {\n    return v === false\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive (value) {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      // $flow-disable-line\n      typeof value === 'symbol' ||\n      typeof value === 'boolean'\n    )\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType (value) {\n    return _toString.call(value).slice(8, -1)\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject (obj) {\n    return _toString.call(obj) === '[object Object]'\n  }\n\n  function isRegExp (v) {\n    return _toString.call(v) === '[object RegExp]'\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex (val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val)\n  }\n\n  function isPromise (val) {\n    return (\n      isDef(val) &&\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString (val) {\n    return val == null\n      ? ''\n      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n        ? JSON.stringify(val, null, 2)\n        : String(val)\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber (val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap (\n    str,\n    expectsLowerCase\n  ) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase\n      ? function (val) { return map[val.toLowerCase()]; }\n      : function (val) { return map[val]; }\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove (arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn (obj, key) {\n    return hasOwnProperty.call(obj, key)\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached (fn) {\n    var cache = Object.create(null);\n    return (function cachedFn (str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str))\n    })\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind (fn, ctx) {\n    function boundFn (a) {\n      var l = arguments.length;\n      return l\n        ? l > 1\n          ? fn.apply(ctx, arguments)\n          : fn.call(ctx, a)\n        : fn.call(ctx)\n    }\n\n    boundFn._length = fn.length;\n    return boundFn\n  }\n\n  function nativeBind (fn, ctx) {\n    return fn.bind(ctx)\n  }\n\n  var bind = Function.prototype.bind\n    ? nativeBind\n    : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray (list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend (to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject (arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop (a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) { return false; };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function (_) { return _; };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys (modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || [])\n    }, []).join(',')\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          /* istanbul ignore next */\n          return false\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf (arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) { return i }\n    }\n    return -1\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once (fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    }\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = [\n    'component',\n    'directive',\n    'filter'\n  ];\n\n  var LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch'\n  ];\n\n  /*  */\n\n\n\n  var config = ({\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  });\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved (str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F\n  }\n\n  /**\n   * Define a property.\n   */\n  function def (obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\n  function parsePath (path) {\n    if (bailRE.test(path)) {\n      return\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = ({}).watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', ({\n        get: function get () {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      })); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative (Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n  }\n\n  var hasSymbol =\n    typeof Symbol !== 'undefined' && isNative(Symbol) &&\n    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/(function () {\n      function Set () {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has (key) {\n        return this.set[key] === true\n      };\n      Set.prototype.add = function add (key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear () {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }());\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = (noop); // work around flow check\n  var formatComponentName = (noop);\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) { return str\n      .replace(classifyRE, function (c) { return c.toUpperCase(); })\n      .replace(/[-_]/g, ''); };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && (!config.silent)) {\n        console.error((\"[Vue warn]: \" + msg + trace));\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && (!config.silent)) {\n        console.warn(\"[Vue tip]: \" + msg + (\n          vm ? generateComponentTrace(vm) : ''\n        ));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>'\n      }\n      var options = typeof vm === 'function' && vm.cid != null\n        ? vm.options\n        : vm._isVue\n          ? vm.$options || vm.constructor.options\n          : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (\n        (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n        (file && includeFile !== false ? (\" at \" + file) : '')\n      )\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) { res += str; }\n        if (n > 1) { str += str; }\n        n >>= 1;\n      }\n      return res\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree\n          .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n              ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n              : formatComponentName(vm))); })\n          .join('\\n')\n      } else {\n        return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep () {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub (sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub (sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify () {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) { return a.id - b.id; });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget (target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget () {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode (\n    tag,\n    data,\n    children,\n    text,\n    elm,\n    context,\n    componentOptions,\n    asyncFactory\n  ) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance\n  };\n\n  Object.defineProperties( VNode.prototype, prototypeAccessors );\n\n  var createEmptyVNode = function (text) {\n    if ( text === void 0 ) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node\n  };\n\n  function createTextVNode (val) {\n    return new VNode(undefined, undefined, undefined, String(val))\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode (vnode) {\n    var cloned = new VNode(\n      vnode.tag,\n      vnode.data,\n      // #7975\n      // clone children array to avoid mutating original in case of cloning\n      // a child.\n      vnode.children && vnode.children.slice(),\n      vnode.text,\n      vnode.elm,\n      vnode.context,\n      vnode.componentOptions,\n      vnode.asyncFactory\n    );\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n  ];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving (value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer (value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment (target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment (target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe (value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (\n      shouldObserve &&\n      !isServerRendering() &&\n      (Array.isArray(value) || isPlainObject(value)) &&\n      Object.isExtensible(value) &&\n      !value._isVue\n    ) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1 (\n    obj,\n    key,\n    val,\n    customSetter,\n    shallow\n  ) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter () {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value\n      },\n      set: function reactiveSetter (newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || (newVal !== newVal && value !== value)) {\n          return\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) { return }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del (target, key) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'\n      );\n      return\n    }\n    if (!hasOwn(target, key)) {\n      return\n    }\n    delete target[key];\n    if (!ob) {\n      return\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray (value) {\n    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\n          \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n          'creation with the `new` keyword.'\n        );\n      }\n      return defaultStrat(parent, child)\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData (to, from) {\n    if (!from) { return to }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol\n      ? Reflect.ownKeys(from)\n      : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') { continue }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (\n        toVal !== fromVal &&\n        isPlainObject(toVal) &&\n        isPlainObject(fromVal)\n      ) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal\n      }\n      if (!parentVal) {\n        return childVal\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn () {\n        return mergeData(\n          typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n        )\n      }\n    } else {\n      return function mergedInstanceDataFn () {\n        // instance merge\n        var instanceData = typeof childVal === 'function'\n          ? childVal.call(vm, vm)\n          : childVal;\n        var defaultData = typeof parentVal === 'function'\n          ? parentVal.call(vm, vm)\n          : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData)\n        } else {\n          return defaultData\n        }\n      }\n    }\n  }\n\n  strats.data = function (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn(\n          'The \"data\" option should be a function ' +\n          'that returns a per-instance value in component ' +\n          'definitions.',\n          vm\n        );\n\n        return parentVal\n      }\n      return mergeDataOrFn(parentVal, childVal)\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm)\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook (\n    parentVal,\n    childVal\n  ) {\n    var res = childVal\n      ? parentVal\n        ? parentVal.concat(childVal)\n        : Array.isArray(childVal)\n          ? childVal\n          : [childVal]\n      : parentVal;\n    return res\n      ? dedupeHooks(res)\n      : res\n  }\n\n  function dedupeHooks (hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal)\n    } else {\n      return res\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) { parentVal = undefined; }\n    if (childVal === nativeWatch) { childVal = undefined; }\n    /* istanbul ignore if */\n    if (!childVal) { return Object.create(parentVal || null) }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent\n        ? parent.concat(child)\n        : Array.isArray(child) ? child : [child];\n    }\n    return ret\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props =\n  strats.methods =\n  strats.inject =\n  strats.computed = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) { extend(ret, childVal); }\n    return ret\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents (options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName (name) {\n    if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'should conform to valid custom element name in html5 specification.'\n      );\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + name\n      );\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps (options, vm) {\n    var props = options.props;\n    if (!props) { return }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val)\n          ? val\n          : { type: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(props)) + \".\",\n        vm\n      );\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject (options, vm) {\n    var inject = options.inject;\n    if (!inject) { return }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val)\n          ? extend({ from: key }, val)\n          : { from: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(inject)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives (options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType (name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\n        \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n        \"but got \" + (toRawType(value)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions (\n    parent,\n    child,\n    vm\n  ) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField (key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset (\n    options,\n    type,\n    id,\n    warnMissing\n  ) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) { return assets[id] }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn(\n        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n        options\n      );\n    }\n    return res\n  }\n\n  /*  */\n\n\n\n  function validateProp (\n    key,\n    propOptions,\n    propsData,\n    vm\n  ) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue (vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn(\n        'Invalid default value for prop \"' + key + '\": ' +\n        'Props with type Object/Array must use a factory function ' +\n        'to return the default value.',\n        vm\n      );\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData &&\n      vm.$options.propsData[key] === undefined &&\n      vm._props[key] !== undefined\n    ) {\n      return vm._props[key]\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function'\n      ? def.call(vm)\n      : def\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp (\n    prop,\n    name,\n    value,\n    vm,\n    absent\n  ) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      );\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\n        getInvalidTypeMessage(name, value, expectedTypes),\n        vm\n      );\n      return\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        );\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType (value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    }\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType (fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : ''\n  }\n\n  function isSameType (a, b) {\n    return getType(a) === getType(b)\n  }\n\n  function getTypeIndex (type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  function getInvalidTypeMessage (name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message\n  }\n\n  function styleValue (value, type) {\n    if (type === 'String') {\n      return (\"\\\"\" + value + \"\\\"\")\n    } else if (type === 'Number') {\n      return (\"\" + (Number(value)))\n    } else {\n      return (\"\" + value)\n    }\n  }\n\n  function isExplicable (value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n  }\n\n  function isBoolean () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n  }\n\n  /*  */\n\n  function handleError (err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while ((cur = cur.$parent)) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) { return }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling (\n    handler,\n    context,\n    args,\n    vm,\n    info\n  ) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n        // issue #9511\n        // avoid catch triggering multiple times when nested calls\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res\n  }\n\n  function globalHandleError (err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info)\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError (err, vm, info) {\n    {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap(\n      'Infinity,undefined,NaN,isFinite,isNaN,' +\n      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n      'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\n        \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n        'referenced during render. Make sure that this property is reactive, ' +\n        'either in the data option, or for class-based components, by ' +\n        'initializing the property. ' +\n        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n        target\n      );\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\n        \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n        'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n        'prevent conflicts with Vue internals' +\n        'See: https://vuejs.org/v2/api/#data',\n        target\n      );\n    };\n\n    var hasProxy =\n      typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set (target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n            return false\n          } else {\n            target[key] = value;\n            return true\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has (target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) ||\n          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n        if (!has && !isAllowed) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return has || !isAllowed\n      }\n    };\n\n    var getHandler = {\n      get: function get (target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return target[key]\n      }\n    };\n\n    initProxy = function initProxy (vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped\n          ? getHandler\n          : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse (val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse (val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n      return\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { _traverse(val[i], seen); }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { _traverse(val[keys[i]], seen); }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    }\n  });\n\n  function createFnInvoker (fns, vm) {\n    function invoker () {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n      }\n    }\n    invoker.fns = fns;\n    return invoker\n  }\n\n  function updateListeners (\n    on,\n    oldOn,\n    add,\n    remove$$1,\n    createOnceHandler,\n    vm\n  ) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\n          \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n          vm\n        );\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook (def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook () {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData (\n    data,\n    Ctor,\n    tag\n  ) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (\n            key !== keyInLowerCase &&\n            attrs && hasOwn(attrs, keyInLowerCase)\n          ) {\n            tip(\n              \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n              (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n              \" \\\"\" + key + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and camelCased \" +\n              \"props need to use their kebab-case equivalents when using in-DOM \" +\n              \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n            );\n          }\n        }\n        checkProp(res, props, key, altKey, true) ||\n        checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res\n  }\n\n  function checkProp (\n    res,\n    hash,\n    key,\n    altKey,\n    preserve\n  ) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren (children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children)\n      }\n    }\n    return children\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren (children) {\n    return isPrimitive(children)\n      ? [createTextVNode(children)]\n      : Array.isArray(children)\n        ? normalizeArrayChildren(children)\n        : undefined\n  }\n\n  function isTextNode (node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n  }\n\n  function normalizeArrayChildren (children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') { continue }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) &&\n            isDef(c.tag) &&\n            isUndef(c.key) &&\n            isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  function initProvide (vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function'\n        ? provide.call(vm)\n        : provide;\n    }\n  }\n\n  function initInjections (vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\n              \"Avoid mutating an injected value directly since the changes will be \" +\n              \"overwritten whenever the provided component re-renders. \" +\n              \"injection being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject (inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') { continue }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function'\n              ? provideDefault.call(vm)\n              : provideDefault;\n          } else {\n            warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n          }\n        }\n      }\n      return result\n    }\n  }\n\n  /*  */\n\n\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &&\n        data && data.slot != null\n      ) {\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n  }\n\n  function isWhitespace (node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' '\n  }\n\n  /*  */\n\n  function normalizeScopedSlots (\n    slots,\n    normalSlots,\n    prevSlots\n  ) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized\n    } else if (\n      isStable &&\n      prevSlots &&\n      prevSlots !== emptyObject &&\n      key === prevSlots.$key &&\n      !hasNormalSlots &&\n      !prevSlots.$hasNormal\n    ) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      (slots)._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res)\n        ? [res] // single vnode\n        : normalizeChildren(res);\n      return res && (\n        res.length === 0 ||\n        (res.length === 1 && res[0].isComment) // #9658\n      ) ? undefined\n        : res\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    (ret)._isVList = true;\n    return ret\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn(\n            'slot v-bind without argument expects an Object',\n            this\n          );\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes)\n    } else {\n      return nodes\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  }\n\n  /*  */\n\n  function isKeyNotMatch (expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1\n    } else {\n      return expect !== actual\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInKeyCode,\n    eventKeyName,\n    builtInKeyName\n  ) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName)\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps (\n    data,\n    tag,\n    value,\n    asProp,\n    isSync\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function ( key ) {\n          if (\n            key === 'class' ||\n            key === 'style' ||\n            isReservedAttribute(key)\n          ) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[(\"update:\" + key)] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop( key );\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic (\n    index,\n    isInFor\n  ) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(\n      this._renderProxy,\n      null,\n      this // for render fns generated for functional component templates\n    );\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  }\n\n  function markStatic (\n    tree,\n    key,\n    isOnce\n  ) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners (data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn(\n          'v-on without argument expects an Object value',\n          this\n        );\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  function resolveScopedSlots (\n    fns, // see flow/vnode\n    res,\n    // the following are added in 2.6\n    hasDynamicKeys,\n    contentHashKey\n  ) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      (res).$key = contentHashKey;\n    }\n    return res\n  }\n\n  /*  */\n\n  function bindDynamicKeys (baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\n          (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n          this\n        );\n      }\n    }\n    return baseObj\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier (value, symbol) {\n    return typeof value === 'string' ? symbol + value : value\n  }\n\n  /*  */\n\n  function installRenderHelpers (target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext (\n    data,\n    props,\n    children,\n    parent,\n    Ctor\n  ) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(\n          data.scopedSlots,\n          this$1.$slots = resolveSlots(children, parent)\n        );\n      }\n      return this$1.$slots\n    };\n\n    Object.defineProperty(this, 'scopedSlots', ({\n      enumerable: true,\n      get: function get () {\n        return normalizeScopedSlots(data.scopedSlots, this.slots())\n      }\n    }));\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode\n      };\n    } else {\n      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent (\n    Ctor,\n    propsData,\n    data,\n    contextVm,\n    children\n  ) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n      if (isDef(data.props)) { mergeProps(props, data.props); }\n    }\n\n    var renderContext = new FunctionalRenderContext(\n      data,\n      props,\n      children,\n      contextVm,\n      Ctor\n    );\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res\n    }\n  }\n\n  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone\n  }\n\n  function mergeProps (to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init (vnode, hydrating) {\n      if (\n        vnode.componentInstance &&\n        !vnode.componentInstance._isDestroyed &&\n        vnode.data.keepAlive\n      ) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(\n          vnode,\n          activeInstance\n        );\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch (oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n      );\n    },\n\n    insert: function insert (vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy (vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent (\n    Ctor,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    if (isUndef(Ctor)) {\n      return\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n      }\n      return\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(\n          asyncFactory,\n          data,\n          context,\n          children,\n          tag\n        )\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children)\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\n      (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n      data, undefined, undefined, undefined, context,\n      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n      asyncFactory\n    );\n\n    return vnode\n  }\n\n  function createComponentInstanceForVnode (\n    vnode, // we know it's MountedComponentVNode but flow doesn't\n    parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options)\n  }\n\n  function installComponentHooks (data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1 (f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel (options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input'\n    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (\n        Array.isArray(existing)\n          ? existing.indexOf(callback) === -1\n          : existing !== callback\n      ) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType,\n    alwaysNormalize\n  ) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType)\n  }\n\n  function _createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType\n  ) {\n    if (isDef(data) && isDef((data).__ob__)) {\n      warn(\n        \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n        'Always create fresh vnode data objects in each render!',\n        context\n      );\n      return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode()\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n    ) {\n      {\n        warn(\n          'Avoid using non-primitive value as key, ' +\n          'use string/number value instead.',\n          context\n        );\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n      typeof children[0] === 'function'\n    ) {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(\n          config.parsePlatformTagName(tag), data, children,\n          undefined, undefined, context\n        );\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(\n          tag, data, children,\n          undefined, undefined, context\n        );\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) { applyNS(vnode, ns); }\n      if (isDef(data)) { registerDeepBindings(data); }\n      return vnode\n    } else {\n      return createEmptyVNode()\n    }\n  }\n\n  function applyNS (vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (\n          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings (data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender (vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin (Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this)\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n          _parentVnode.data.scopedSlots,\n          vm.$slots,\n          vm.$scopedSlots\n        );\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn(\n            'Multiple root nodes returned from render function. Render function ' +\n            'should return a single root node.',\n            vm\n          );\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode\n    };\n  }\n\n  /*  */\n\n  function ensureCtor (comp, base) {\n    if (\n      comp.__esModule ||\n      (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n    ) {\n      comp = comp.default;\n    }\n    return isObject(comp)\n      ? base.extend(comp)\n      : comp\n  }\n\n  function createAsyncPlaceholder (\n    factory,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node\n  }\n\n  function resolveAsyncComponent (\n    factory,\n    baseCtor\n  ) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved\n    }\n\n    var owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null\n\n      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          (owners[i]).$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\n          \"Failed to resolve async component: \" + (String(factory)) +\n          (reason ? (\"\\nReason: \" + reason) : '')\n        );\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n              if (isUndef(factory.resolved)) {\n                reject(\n                  \"timeout (\" + (res.timeout) + \"ms)\"\n                );\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading\n        ? factory.loadingComp\n        : factory.resolved\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder (node) {\n    return node.isComment && node.asyncFactory\n  }\n\n  /*  */\n\n  function getFirstComponentChild (children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents (vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add (event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1 (event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler (event, fn) {\n    var _target = target;\n    return function onceHandler () {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    }\n  }\n\n  function updateComponentListeners (\n    vm,\n    listeners,\n    oldListeners\n  ) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin (Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on () {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\n            \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n            (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and you cannot use \" +\n            \"v-on to listen to camelCase events when using in-DOM templates. \" +\n            \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n          );\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    }\n  }\n\n  function initLifecycle (vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin (Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent (\n    vm,\n    el,\n    hydrating\n  ) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n          vm.$options.el || el) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure((\"vue \" + name + \" patch\"), startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before () {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  }\n\n  function updateChildComponent (\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(\n      (newScopedSlots && !newScopedSlots.$stable) ||\n      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n    );\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(\n      renderChildren ||               // has new static slots\n      vm.$options._renderChildren ||  // has old static slots\n      hasDynamicScopedSlot\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree (vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) { return true }\n    }\n    return false\n  }\n\n  function activateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    } else if (vm._directInactive) {\n      return\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook (vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState () {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n    if (\n      performance &&\n      typeof performance.now === 'function' &&\n      getNow() > document.createEvent('Event').timeStamp\n    ) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function () { return performance.now(); };\n    }\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue () {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) { return a.id - b.id; });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn(\n            'You may have an infinite update loop ' + (\n              watcher.user\n                ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                : \"in a component render function.\"\n            ),\n            watcher.vm\n          );\n          break\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks (queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent (vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks (queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher (watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        );\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get () {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps () {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run () {\n    if (this.active) {\n      var value = this.get();\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate () {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy (target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter () {\n      return this[sourceKey][key]\n    };\n    sharedPropertyDefinition.set = function proxySetter (val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState (vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) { initProps(vm, opts.props); }\n    if (opts.methods) { initMethods(vm, opts.methods); }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) { initComputed(vm, opts.computed); }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps (vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function ( key ) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) ||\n            config.isReservedAttr(hyphenatedKey)) {\n          warn(\n            (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop( key );\n    toggleObserving(true);\n  }\n\n  function initData (vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function'\n      ? getData(data, vm)\n      : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn(\n        'data functions should return an object:\\n' +\n        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n        vm\n      );\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n            vm\n          );\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n          \"Use prop default value instead.\",\n          vm\n        );\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData (data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm)\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {}\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed (vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\n          (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(\n          vm,\n          getter || noop,\n          noop,\n          computedWatcherOptions\n        );\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed (\n    target,\n    key,\n    userDef\n  ) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get\n        ? shouldCache && userDef.cache !== false\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef.get)\n        : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\n          (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n          this\n        );\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter (key) {\n    return function computedGetter () {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value\n      }\n    }\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter () {\n      return fn.call(this, this)\n    }\n  }\n\n  function initMethods (vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\n            \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n            \"Did you reference the function correctly?\",\n            vm\n          );\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n            vm\n          );\n        }\n        if ((key in vm) && isReserved(key)) {\n          warn(\n            \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n            \"Avoid defining component methods that start with _ or $.\"\n          );\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch (vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher (\n    vm,\n    expOrFn,\n    handler,\n    options\n  ) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options)\n  }\n\n  function stateMixin (Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () { return this._data };\n    var propsDef = {};\n    propsDef.get = function () { return this._props };\n    {\n      dataDef.set = function () {\n        warn(\n          'Avoid replacing instance root $data. ' +\n          'Use nested data properties instead.',\n          this\n        );\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (\n      expOrFn,\n      cb,\n      options\n    ) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options)\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n        }\n      }\n      return function unwatchFn () {\n        watcher.teardown();\n      }\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + (vm._uid);\n        endTag = \"vue-perf-end:\" + (vm._uid);\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(\n          resolveConstructorOptions(vm.constructor),\n          options || {},\n          vm\n        );\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n\n  function resolveModifiedOptions (Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) { modified = {}; }\n        modified[key] = latest[key];\n      }\n    }\n    return modified\n  }\n\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse (Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initMixin$1 (Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initExtend (Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent (options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(\n        Super.options,\n        extendOptions\n      );\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub\n    };\n  }\n\n  function initProps$1 (Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1 (Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters (Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (\n        id,\n        definition\n      ) {\n        if (!definition) {\n          return this.options[type + 's'][id]\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition\n        }\n      };\n    });\n  }\n\n  /*  */\n\n\n\n  function getComponentName (opts) {\n    return opts && (opts.Ctor.options.name || opts.tag)\n  }\n\n  function matches (pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name)\n    }\n    /* istanbul ignore next */\n    return false\n  }\n\n  function pruneCache (keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry (\n    cache,\n    key,\n    keys,\n    current\n  ) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created () {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed () {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted () {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) { return matches(val, name); });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) { return !matches(val, name); });\n      });\n    },\n\n    render: function render () {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n          // not included\n          (include && (!name || !matches(include, name))) ||\n          // excluded\n          (exclude && name && matches(exclude, name))\n        ) {\n          return vnode\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n          // same constructor may get registered as different local components\n          // so cid alone is not enough (#3269)\n          ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n          : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || (slot && slot[0])\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI (Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    {\n      configDef.set = function () {\n        warn(\n          'Do not replace the Vue.config object, set individual fields instead.'\n        );\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get () {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.10';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return (\n      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n      (attr === 'selected' && tag === 'option') ||\n      (attr === 'checked' && tag === 'input') ||\n      (attr === 'muted' && tag === 'video')\n    )\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n      ? 'false'\n      // allow arbitrary string value for contenteditable\n      : key === 'contenteditable' && isValidContentEditableValue(value)\n        ? value\n        : 'true'\n  };\n\n  var isBooleanAttr = makeMap(\n    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,translate,' +\n    'truespeed,typemustmatch,visible'\n  );\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : ''\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false\n  };\n\n  /*  */\n\n  function genClassForVnode (vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class)\n  }\n\n  function mergeClassData (child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class)\n        ? [child.class, parent.class]\n        : parent.class\n    }\n  }\n\n  function renderClass (\n    staticClass,\n    dynamicClass\n  ) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass))\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function concat (a, b) {\n    return a ? b ? (a + ' ' + b) : a : (b || '')\n  }\n\n  function stringifyClass (value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value)\n    }\n    if (isObject(value)) {\n      return stringifyObject(value)\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function stringifyArray (value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) { res += ' '; }\n        res += stringified;\n      }\n    }\n    return res\n  }\n\n  function stringifyObject (value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) { res += ' '; }\n        res += key;\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n  );\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n  );\n\n  var isPreTag = function (tag) { return tag === 'pre'; };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag)\n  };\n\n  function getTagNamespace (tag) {\n    if (isSVG(tag)) {\n      return 'svg'\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math'\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement (tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true\n    }\n    if (isReservedTag(tag)) {\n      return false\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag]\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return (unknownElementCache[tag] = (\n        el.constructor === window.HTMLUnknownElement ||\n        el.constructor === window.HTMLElement\n      ))\n    } else {\n      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query (el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn(\n          'Cannot find element: ' + el\n        );\n        return document.createElement('div')\n      }\n      return selected\n    } else {\n      return el\n    }\n  }\n\n  /*  */\n\n  function createElement$1 (tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm\n  }\n\n  function createElementNS (namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName)\n  }\n\n  function createTextNode (text) {\n    return document.createTextNode(text)\n  }\n\n  function createComment (text) {\n    return document.createComment(text)\n  }\n\n  function insertBefore (parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild (node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild (node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode (node) {\n    return node.parentNode\n  }\n\n  function nextSibling (node) {\n    return node.nextSibling\n  }\n\n  function tagName (node) {\n    return node.tagName\n  }\n\n  function setTextContent (node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope (node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create (_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update (oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy (vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef (vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) { return }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode (a, b) {\n    return (\n      a.key === b.key && (\n        (\n          a.tag === b.tag &&\n          a.isComment === b.isComment &&\n          isDef(a.data) === isDef(b.data) &&\n          sameInputType(a, b)\n        ) || (\n          isTrue(a.isAsyncPlaceholder) &&\n          a.asyncFactory === b.asyncFactory &&\n          isUndef(b.asyncFactory.error)\n        )\n      )\n    )\n  }\n\n  function sameInputType (a, b) {\n    if (a.tag !== 'input') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n  }\n\n  function createKeyToOldIdx (children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) { map[key] = i; }\n    }\n    return map\n  }\n\n  function createPatchFunction (backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt (elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n    }\n\n    function createRmCb (childElm, listeners) {\n      function remove$$1 () {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1\n    }\n\n    function removeNode (el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1 (vnode, inVPre) {\n      return (\n        !inVPre &&\n        !vnode.ns &&\n        !(\n          config.ignoredElements.length &&\n          config.ignoredElements.some(function (ignore) {\n            return isRegExp(ignore)\n              ? ignore.test(vnode.tag)\n              : ignore === vnode.tag\n          })\n        ) &&\n        config.isUnknownElement(vnode.tag)\n      )\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm (\n      vnode,\n      insertedVnodeQueue,\n      parentElm,\n      refElm,\n      nested,\n      ownerArray,\n      index\n    ) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn(\n              'Unknown custom element: <' + tag + '> - did you ' +\n              'register the component correctly? For recursive components, ' +\n              'make sure to provide the \"name\" option.',\n              vnode.context\n            );\n          }\n        }\n\n        vnode.elm = vnode.ns\n          ? nodeOps.createElementNS(vnode.ns, tag)\n          : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true\n        }\n      }\n    }\n\n    function initComponent (vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert (parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren (vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable (vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag)\n    }\n\n    function invokeCreateHooks (vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) { i.create(emptyNode, vnode); }\n        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope (vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        i !== vnode.fnContext &&\n        isDef(i = i.$options._scopeId)\n      ) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook (vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else { // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook (vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n          idxInOld = isDef(newStartVnode.key)\n            ? oldKeyToIdx[newStartVnode.key]\n            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) { // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys (children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\n              (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n              vnode.context\n            );\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld (node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) { return i }\n      }\n    }\n\n    function patchVnode (\n      oldVnode,\n      vnode,\n      insertedVnodeQueue,\n      ownerArray,\n      index,\n      removeOnly\n    ) {\n      if (oldVnode === vnode) {\n        return\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n      ) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n      }\n    }\n\n    function invokeInsertHook (vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || (data && data.pre);\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true\n    }\n\n    function assertNodeMatch (node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || (\n          !isUnknownElement$$1(vnode, inVPre) &&\n          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n        )\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3)\n      }\n    }\n\n    return function patch (oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n        return\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode\n              } else {\n                warn(\n                  'The client-side rendered virtual DOM tree is not matching ' +\n                  'server-rendered content. This is likely caused by incorrect ' +\n                  'HTML markup, for example nesting block-level elements inside ' +\n                  '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                  'full client-side render.'\n                );\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(\n            vnode,\n            insertedVnodeQueue,\n            // extremely rare edge case: do not insert if old element is in a\n            // leaving transition. Only happens when combining transition +\n            // keep-alive + HOCs. (#4590)\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n          );\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm\n    }\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives (vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives (oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update (oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1 (\n    dirs,\n    vm\n  ) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res\n  }\n\n  function getRawDirName (dir) {\n    return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n  }\n\n  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n      }\n    }\n  }\n\n  var baseModules = [\n    ref,\n    directives\n  ];\n\n  /*  */\n\n  function updateAttrs (oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr (el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n          ? 'true'\n          : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr (el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && value !== '' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass (oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (\n      isUndef(data.staticClass) &&\n      isUndef(data.class) && (\n        isUndef(oldData) || (\n          isUndef(oldData.staticClass) &&\n          isUndef(oldData.class)\n        )\n      )\n    ) {\n      return\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters (exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n      } else if (\n        c === 0x7C && // pipe\n        exp.charCodeAt(i + 1) !== 0x7C &&\n        exp.charCodeAt(i - 1) !== 0x7C &&\n        !curly && !square && !paren\n      ) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22: inDouble = true; break         // \"\n          case 0x27: inSingle = true; break         // '\n          case 0x60: inTemplateString = true; break // `\n          case 0x28: paren++; break                 // (\n          case 0x29: paren--; break                 // )\n          case 0x5B: square++; break                // [\n          case 0x5D: square--; break                // ]\n          case 0x7B: curly++; break                 // {\n          case 0x7D: curly--; break                 // }\n        }\n        if (c === 0x2f) { // /\n          var j = i - 1;\n          var p = (void 0);\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') { break }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter () {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression\n  }\n\n  function wrapFilter (exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n    }\n  }\n\n  /*  */\n\n\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn (msg, range) {\n    console.error((\"[Vue compiler]: \" + msg));\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction (\n    modules,\n    key\n  ) {\n    return modules\n      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n      : []\n  }\n\n  function addProp (el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr (el, name, value, range, dynamic) {\n    var attrs = dynamic\n      ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n      : (el.attrs || (el.attrs = []));\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr (el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective (\n    el,\n    name,\n    rawName,\n    value,\n    arg,\n    isDynamicArg,\n    modifiers,\n    range\n  ) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker (symbol, name, dynamic) {\n    return dynamic\n      ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n      : symbol + name // mark the event as captured\n  }\n\n  function addHandler (\n    el,\n    name,\n    value,\n    modifiers,\n    important,\n    warn,\n    range,\n    dynamic\n  ) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\n      warn &&\n      modifiers.prevent && modifiers.passive\n    ) {\n      warn(\n        'passive and prevent can\\'t be used together. ' +\n        'Passive handler can\\'t prevent default event.',\n        range\n      );\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr (\n    el,\n    name\n  ) {\n    return el.rawAttrsMap[':' + name] ||\n      el.rawAttrsMap['v-bind:' + name] ||\n      el.rawAttrsMap[name]\n  }\n\n  function getBindingAttr (\n    el,\n    name,\n    getStatic\n  ) {\n    var dynamicValue =\n      getAndRemoveAttr(el, ':' + name) ||\n      getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue)\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue)\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr (\n    el,\n    name,\n    removeFromMap\n  ) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val\n  }\n\n  function getAndRemoveAttrByRegex (\n    el,\n    name\n  ) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr\n      }\n    }\n  }\n\n  function rangeSetItem (\n    item,\n    range\n  ) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression =\n        \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: (\"(\" + value + \")\"),\n      expression: JSON.stringify(value),\n      callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode (\n    value,\n    assignment\n  ) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return (value + \"=\" + assignment)\n    } else {\n      return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\n  function parseModel (val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        }\n      } else {\n        return {\n          exp: val,\n          key: null\n        }\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    }\n  }\n\n  function next () {\n    return str.charCodeAt(++index$1)\n  }\n\n  function eof () {\n    return index$1 >= len\n  }\n\n  function isStringStart (chr) {\n    return chr === 0x22 || chr === 0x27\n  }\n\n  function parseBracket (chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue\n      }\n      if (chr === 0x5B) { inBracket++; }\n      if (chr === 0x5D) { inBracket--; }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break\n      }\n    }\n  }\n\n  function parseString (chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model (\n    el,\n    dir,\n    _warn\n  ) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n          \"File inputs are read only. Use a v-on:change listener instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"v-model is not supported on this element type. \" +\n        'If you are working with contenteditable, it\\'s recommended to ' +\n        'wrap a library dedicated for that purpose inside a custom component.',\n        el.rawAttrsMap['v-model']\n      );\n    }\n\n    // ensure runtime directive metadata\n    return true\n  }\n\n  function genCheckboxModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked',\n      \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n    );\n    addHandler(el, 'change',\n      \"var $$a=\" + value + \",\" +\n          '$$el=$event.target,' +\n          \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n      'if(Array.isArray($$a)){' +\n        \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n            '$$i=_i($$a,$$v);' +\n        \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n        \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n      \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n      null, true\n    );\n  }\n\n  function genRadioModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n    addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" +\n      \".call($event.target.options,function(o){return o.selected})\" +\n      \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n      \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + (genAssignmentCode(value, assignment));\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(\n          binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n          'because the latter already expands to a value binding internally',\n          el.rawAttrsMap[binding]\n        );\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy\n      ? 'change'\n      : type === 'range'\n        ? RANGE_TOKEN\n        : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', (\"(\" + value + \")\"));\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents (on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1 (event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler () {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    }\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1 (\n    name,\n    handler,\n    capture,\n    passive\n  ) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n          // no bubbling, should always fire.\n          // this is just a safety net in case event.timeStamp is unreliable in\n          // certain weird environments...\n          e.target === e.currentTarget ||\n          // event is fired after handler attachment\n          e.timeStamp >= attachedTimestamp ||\n          // bail for environments that have buggy event.timeStamp implementations\n          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n          // #9681 QtWebEngine event.timeStamp is negative value\n          e.timeStamp <= 0 ||\n          // #9448 bail if event is fired in another document in a multi-page\n          // electron/nw.js app, since event.timeStamp will be using a different\n          // starting reference\n          e.target.ownerDocument !== document\n        ) {\n          return original.apply(this, arguments)\n        }\n      };\n    }\n    target$1.addEventListener(\n      name,\n      handler,\n      supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n  }\n\n  function remove$2 (\n    name,\n    handler,\n    capture,\n    _target\n  ) {\n    (_target || target$1).removeEventListener(\n      name,\n      handler._wrapper || handler,\n      capture\n    );\n  }\n\n  function updateDOMListeners (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) { vnode.children.length = 0; }\n        if (cur === oldProps[key]) { continue }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecesarry `checked` update.\n        cur !== oldProps[key]\n      ) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue (elm, checkVal) {\n    return (!elm.composing && (\n      elm.tagName === 'OPTION' ||\n      isNotInFocusAndDirty(elm, checkVal) ||\n      isDirtyWithModifiers(elm, checkVal)\n    ))\n  }\n\n  function isNotInFocusAndDirty (elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try { notInFocus = document.activeElement !== elm; } catch (e) {}\n    return notInFocus && elm.value !== checkVal\n  }\n\n  function isDirtyWithModifiers (elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal)\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim()\n      }\n    }\n    return value !== newVal\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData (data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle\n      ? extend(data.staticStyle, style)\n      : style\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding (bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle)\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle)\n    }\n    return bindingStyle\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle (vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (\n          childNode && childNode.data &&\n          (styleData = normalizeStyleData(childNode.data))\n        ) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if ((styleData = normalizeStyleData(vnode.data))) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while ((parentNode = parentNode.parent)) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && (prop in emptyStyle)) {\n      return prop\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  });\n\n  function updateStyle (oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) &&\n      isUndef(oldData.staticStyle) && isUndef(oldData.style)\n    ) {\n      return\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__)\n      ? extend({}, style)\n      : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition (def$$1) {\n    if (!def$$1) {\n      return\n    }\n    /* istanbul ignore else */\n    if (typeof def$$1 === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1)\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: (name + \"-enter\"),\n      enterToClass: (name + \"-enter-to\"),\n      enterActiveClass: (name + \"-enter-active\"),\n      leaveClass: (name + \"-leave\"),\n      leaveToClass: (name + \"-leave-to\"),\n      leaveActiveClass: (name + \"-leave-active\")\n    }\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n      window.onwebkittransitionend !== undefined\n    ) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n      window.onwebkitanimationend !== undefined\n    ) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser\n    ? window.requestAnimationFrame\n      ? window.requestAnimationFrame.bind(window)\n      : setTimeout\n    : /* istanbul ignore next */ function (fn) { return fn(); };\n\n  function nextFrame (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass (el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass (el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds (\n    el,\n    expectedType,\n    cb\n  ) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) { return cb() }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo (el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null;\n      propCount = type\n        ? type === TRANSITION\n          ? transitionDurations.length\n          : animationDurations.length\n        : 0;\n    }\n    var hasTransform =\n      type === TRANSITION &&\n      transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    }\n  }\n\n  function getTimeout (delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i])\n    }))\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs (s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000\n  }\n\n  /*  */\n\n  function enter (vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return\n    }\n\n    var startClass = isAppear && appearClass\n      ? appearClass\n      : enterClass;\n    var activeClass = isAppear && appearActiveClass\n      ? appearActiveClass\n      : enterActiveClass;\n    var toClass = isAppear && appearToClass\n      ? appearToClass\n      : enterToClass;\n\n    var beforeEnterHook = isAppear\n      ? (beforeAppear || beforeEnter)\n      : beforeEnter;\n    var enterHook = isAppear\n      ? (typeof appear === 'function' ? appear : enter)\n      : enter;\n    var afterEnterHook = isAppear\n      ? (afterAppear || afterEnter)\n      : afterEnter;\n    var enterCancelledHook = isAppear\n      ? (appearCancelled || enterCancelled)\n      : enterCancelled;\n\n    var explicitEnterDuration = toNumber(\n      isObject(duration)\n        ? duration.enter\n        : duration\n    );\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb\n        ) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave (vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm()\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(\n      isObject(duration)\n        ? duration.leave\n        : duration\n    );\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave () {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration (val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\n        \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n        \"got \" + (JSON.stringify(val)) + \".\",\n        vnode.context\n      );\n    } else if (isNaN(val)) {\n      warn(\n        \"<transition> explicit \" + name + \" duration is NaN - \" +\n        'the duration expression might be incorrect.',\n        vnode.context\n      );\n    }\n  }\n\n  function isValidDuration (val) {\n    return typeof val === 'number' && !isNaN(val)\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength (fn) {\n    if (isUndef(fn)) {\n      return false\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(\n        Array.isArray(invokerFns)\n          ? invokerFns[0]\n          : invokerFns\n      )\n    } else {\n      return (fn._length || fn.length) > 1\n    }\n  }\n\n  function _enter (_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1 (vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [\n    attrs,\n    klass,\n    events,\n    domProps,\n    style,\n    transition\n  ];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted (el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated (el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple\n            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected (el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected (el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\n        \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n        \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n        vm\n      );\n      return\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption (value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); })\n  }\n\n  function getValue (option) {\n    return '_value' in option\n      ? option._value\n      : option.value\n  }\n\n  function onCompositionStart (e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd (e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) { return }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger (el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode (vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n      ? locateNode(vnode.componentInstance._vnode)\n      : vnode\n  }\n\n  var show = {\n    bind: function bind (el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay =\n        el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update (el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) { return }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind (\n      el,\n      binding,\n      vnode,\n      oldVnode,\n      isDestroy\n    ) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild (vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children))\n    } else {\n      return vnode\n    }\n  }\n\n  function extractTransitionData (comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data\n  }\n\n  function placeholder (h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      })\n    }\n  }\n\n  function hasParentTransition (vnode) {\n    while ((vnode = vnode.parent)) {\n      if (vnode.data.transition) {\n        return true\n      }\n    }\n  }\n\n  function isSameChild (child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag\n  }\n\n  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\n  var isVShowDirective = function (d) { return d.name === 'show'; };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render (h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element. Use ' +\n          '<transition-group> for lists.',\n          this.$parent\n        );\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in'\n      ) {\n        warn(\n          'invalid <transition> mode: ' + mode,\n          this.$parent\n        );\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild)\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + (this._uid) + \"-\";\n      child.key = child.key == null\n        ? child.isComment\n          ? id + 'comment'\n          : id + child.tag\n        : isPrimitive(child.key)\n          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n          : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (\n        oldChild &&\n        oldChild.data &&\n        !isSameChild(child, oldChild) &&\n        !isAsyncPlaceholder(oldChild) &&\n        // #6687 component root is a comment node\n        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n      ) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild)\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild\n          }\n          var delayedLeave;\n          var performLeave = function () { delayedLeave(); };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n        }\n      }\n\n      return rawChild\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount () {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(\n          this$1._vnode,\n          this$1.kept,\n          false, // hydrating\n          true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render (h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c\n            ;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n            warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children)\n    },\n\n    updated: function updated () {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n            if (e && e.target !== el) {\n              return\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove (el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return (this._hasMove = info.hasTransform)\n      }\n    }\n  };\n\n  function callPendingCbs (c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition (c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation (c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating)\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log'](\n            'Download the Vue Devtools extension for a better development experience:\\n' +\n            'https://github.com/vuejs/vue-devtools'\n          );\n        }\n      }\n      if (config.productionTip !== false &&\n        typeof console !== 'undefined'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          \"You are running Vue in development mode.\\n\" +\n          \"Make sure to turn on production mode when deploying for production.\\n\" +\n          \"See more tips at https://vuejs.org/guide/deployment.html\"\n        );\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n  });\n\n\n\n  function parseText (\n    text,\n    delimiters\n  ) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push((\"_s(\" + exp + \")\"));\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    }\n  }\n\n  /*  */\n\n  function transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1 (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\n            \"style=\\\"\" + staticStyle + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n            el.rawAttrsMap['style']\n          );\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1 (el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + (el.staticStyle) + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + (el.styleBinding) + \"),\";\n    }\n    return data\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode (html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap(\n    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr'\n  );\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap(\n    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n  );\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap(\n    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track'\n  );\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\n  function decodeAttr (value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) { return decodingMap[match]; })\n  }\n\n  function parseHTML (html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue\n          }\n        }\n\n        var text = (void 0), rest = (void 0), next = (void 0);\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (\n            !endTag.test(rest) &&\n            !startTagOpen.test(rest) &&\n            !comment.test(rest) &&\n            !conditionalComment.test(rest)\n          ) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) { break }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return ''\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n        }\n        break\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance (n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag () {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match\n        }\n      }\n    }\n\n    function handleStartTag (match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n          ? options.shouldDecodeNewlinesForHref\n          : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag (tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) { start = index; }\n      if (end == null) { end = index; }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName &&\n            options.warn\n          ) {\n            options.warn(\n              (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n              { start: stack[i].start, end: stack[i].end }\n            );\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement (\n    tag,\n    attrs,\n    parent\n  ) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    }\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse (\n    template,\n    options\n  ) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce (msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement (element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\",\n            { start: element.start }\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"'\n            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) { return !(c).slotScope; });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace (el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while (\n          (lastNode = el.children[el.children.length - 1]) &&\n          lastNode.type === 3 &&\n          lastNode.text === ' '\n        ) {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints (el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\n          \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n          'contain multiple nodes.',\n          { start: el.start }\n        );\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce(\n          'Cannot use v-for on stateful component root element because ' +\n          'it renders multiple elements.',\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start (tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\n                \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                \"spaces, quotes, <, >, / or =.\",\n                {\n                  start: attr.start + attr.name.indexOf(\"[\"),\n                  end: attr.start + attr.name.length\n                }\n              );\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2(\n            'Templates should only be responsible for mapping the state to the ' +\n            'UI. Avoid placing tags with side-effects in your templates, such as ' +\n            \"<\" + tag + \">\" + ', as they will not be parsed.',\n            { start: element.start }\n          );\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end (tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars (text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce(\n                'Component template requires a root element, rather than just text.',\n                { start: start }\n              );\n            } else if ((text = text.trim())) {\n              warnOnce(\n                (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                { start: start }\n              );\n            }\n          }\n          return\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text\n        ) {\n          return\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment (text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root\n  }\n\n  function processPre (el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs (el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement (\n    element,\n    options\n  ) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = (\n      !element.key &&\n      !element.scopedSlots &&\n      !element.attrsList.length\n    );\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element\n  }\n\n  function processKey (el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\n            \"<template> cannot be keyed. Place the key on real elements instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\n              \"Do not use v-for index as key on <transition-group> children, \" +\n              \"this is the same as not using keys.\",\n              getRawBindingAttr(el, 'key'),\n              true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef (el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor (el) {\n    var exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\n          (\"Invalid v-for expression: \" + exp),\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n  }\n\n\n\n  function parseFor (exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) { return }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res\n  }\n\n  function processIf (el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions (el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\n        \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n        \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n      );\n    }\n  }\n\n  function findPrevElement (children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i]\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\n            \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n            \"will be ignored.\",\n            children[i]\n          );\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition (el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce (el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent (el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          el.rawAttrsMap['scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          el.rawAttrsMap['slot-scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\n                \"<template v-slot> can only appear at the root level inside \" +\n                \"the receiving the component\",\n                el\n              );\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\n                \"v-slot can only be used on components or <template>.\",\n                slotBinding$1\n              );\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.scopedSlots) {\n              warn$2(\n                \"To avoid scope ambiguity, the default slot should also use \" +\n                \"<template> syntax when there are other named slots.\",\n                slotBinding$1\n              );\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName (binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\n          \"v-slot shorthand syntax requires a slot name.\",\n          binding\n        );\n      }\n    }\n    return dynamicArgRE.test(name)\n      // dynamic [name]\n      ? { name: name.slice(1, -1), dynamic: true }\n      // static name\n      : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet (el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\n          \"`key` does not work on <slot> because slots are abstract outlets \" +\n          \"and can possibly expand into multiple elements. \" +\n          \"Use the key on a wrapping element instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n    }\n  }\n\n  function processComponent (el) {\n    var binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs (el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) { // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (\n            value.trim().length === 0\n          ) {\n            warn$2(\n              (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n            );\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') { name = 'innerHTML'; }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(\n                  el,\n                  (\"update:\" + (camelize(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (hyphenate(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(\n                  el,\n                  (\"\\\"update:\\\"+(\" + name + \")\"),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i],\n                  true // dynamic\n                );\n              }\n            }\n          }\n          if ((modifiers && modifiers.prop) || (\n            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n          )) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) { // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else { // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(\n              name + \"=\\\"\" + value + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n              list[i]\n            );\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component &&\n            name === 'muted' &&\n            platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor (el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true\n      }\n      parent = parent.parent;\n    }\n    return false\n  }\n\n  function parseModifiers (name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) { ret[m.slice(1)] = true; });\n      return ret\n    }\n  }\n\n  function makeAttrsMap (attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\n        map[attrs[i].name] && !isIE && !isEdge\n      ) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag (el) {\n    return el.tag === 'script' || el.tag === 'style'\n  }\n\n  function isForbiddenTag (el) {\n    return (\n      el.tag === 'style' ||\n      (el.tag === 'script' && (\n        !el.attrsMap.type ||\n        el.attrsMap.type === 'text/javascript'\n      ))\n    )\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug (attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res\n  }\n\n  function checkForAliasModel (el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"You are binding v-model directly to a v-for iteration alias. \" +\n          \"This will not be able to modify the v-for source array because \" +\n          \"writing to the alias is like modifying a function local variable. \" +\n          \"Consider using an array of objects and use v-model on an object property instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode (el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + (map['v-bind']) + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0\n      }\n    }\n  }\n\n  function cloneASTElement (el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [\n    klass$1,\n    style$1,\n    model$1\n  ];\n\n  /*  */\n\n  function text (el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  /*  */\n\n  function html (el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize (root, options) {\n    if (!root) { return }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1 (keys) {\n    return makeMap(\n      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n      (keys ? ',' + keys : '')\n    )\n  }\n\n  function markStatic$1 (node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (\n        !isPlatformReservedTag(node.tag) &&\n        node.tag !== 'slot' &&\n        node.attrsMap['inline-template'] == null\n      ) {\n        return\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots (node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(\n        node.children.length === 1 &&\n        node.children[0].type === 3\n      )) {\n        node.staticRoot = true;\n        return\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic (node) {\n    if (node.type === 2) { // expression\n      return false\n    }\n    if (node.type === 3) { // text\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // no dynamic bindings\n      !node.if && !node.for && // not v-if or v-for or v-else\n      !isBuiltInTag(node.tag) && // not a built-in\n      isPlatformReservedTag(node.tag) && // not a component\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n\n  function isDirectChildOfTemplateFor (node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false\n      }\n      if (node.for) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers (\n    events,\n    isNative\n  ) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n    } else {\n      return prefix + staticHandlers\n    }\n  }\n\n  function genHandler (handler) {\n    if (!handler) {\n      return 'function(){}'\n    }\n\n    if (Array.isArray(handler)) {\n      return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value\n      }\n      return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = (handler.modifiers);\n          genModifierCode += genGuard(\n            ['ctrl', 'shift', 'alt', 'meta']\n              .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n              .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n              .join('||')\n          );\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath\n        ? (\"return \" + (handler.value) + \"($event)\")\n        : isFunctionExpression\n          ? (\"return (\" + (handler.value) + \")($event)\")\n          : isFunctionInvocation\n            ? (\"return \" + (handler.value))\n            : handler.value;\n      return (\"function($event){\" + code + handlerCode + \"}\")\n    }\n  }\n\n  function genKeyFilter (keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" +\n      (keys.map(genFilterCode).join('&&')) + \")return null;\"\n    )\n  }\n\n  function genFilterCode (key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return (\"$event.keyCode!==\" + keyVal)\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return (\n      \"_k($event.keyCode,\" +\n      (JSON.stringify(key)) + \",\" +\n      (JSON.stringify(keyCode)) + \",\" +\n      \"$event.key,\" +\n      \"\" + (JSON.stringify(keyName)) +\n      \")\"\n    )\n  }\n\n  /*  */\n\n  function on (el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n  }\n\n  /*  */\n\n  function bind$1 (el, dir) {\n    el.wrapData = function (code) {\n      return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n\n\n\n\n  var CodegenState = function CodegenState (options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n\n\n  function generate (\n    ast,\n    options\n  ) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: (\"with(this){return \" + code + \"}\"),\n      staticRenderFns: state.staticRenderFns\n    }\n  }\n\n  function genElement (el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state)\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state)\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state)\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0'\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state)\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || (el.pre && state.maybeComponent(el))) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic (el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n    state.pre = originalPreState;\n    return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  }\n\n  // v-once\n  function genOnce (el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\n          \"v-once can only be used inside v-for that is keyed. \",\n          el.rawAttrsMap['v-once']\n        );\n        return genElement(el, state)\n      }\n      return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n    } else {\n      return genStatic(el, state)\n    }\n  }\n\n  function genIf (\n    el,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n  }\n\n  function genIfConditions (\n    conditions,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    if (!conditions.length) {\n      return altEmpty || '_e()'\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n    } else {\n      return (\"\" + (genTernaryExp(condition.block)))\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp (el) {\n      return altGen\n        ? altGen(el, state)\n        : el.once\n          ? genOnce(el, state)\n          : genElement(el, state)\n    }\n  }\n\n  function genFor (\n    el,\n    state,\n    altGen,\n    altHelper\n  ) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n    var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n    if (state.maybeComponent(el) &&\n      el.tag !== 'slot' &&\n      el.tag !== 'template' &&\n      !el.key\n    ) {\n      state.warn(\n        \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n        \"v-for should have explicit keys. \" +\n        \"See https://vuejs.org/guide/list.html#key for more info.\",\n        el.rawAttrsMap['v-for'],\n        true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" +\n      \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n        \"return \" + ((altGen || genElement)(el, state)) +\n      '})'\n  }\n\n  function genData$2 (el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) { data += dirs + ','; }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + (el.key) + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + (el.ref) + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + (genProps(el.props)) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += (genHandlers(el.events, false)) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += (genHandlers(el.nativeEvents, true)) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + (el.slotTarget) + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data\n  }\n\n  function genDirectives (el, state) {\n    var dirs = el.directives;\n    if (!dirs) { return }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']'\n    }\n  }\n\n  function genInlineTemplate (el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn(\n        'Inline-template components must have exactly one child element.',\n        { start: el.start }\n      );\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n    }\n  }\n\n  function genScopedSlots (\n    el,\n    slots,\n    state\n  ) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return (\n        slot.slotTargetDynamic ||\n        slot.if ||\n        slot.for ||\n        containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      )\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (\n          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n          parent.for\n        ) {\n          needsForceUpdate = true;\n          break\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots)\n      .map(function (key) { return genScopedSlot(slots[key], state); })\n      .join(',');\n\n    return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while(i) {\n      hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0\n  }\n\n  function containsSlotChild (el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true\n      }\n      return el.children.some(containsSlotChild)\n    }\n    return false\n  }\n\n  function genScopedSlot (\n    el,\n    state\n  ) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\")\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot)\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken\n      ? \"\"\n      : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" +\n      \"return \" + (el.tag === 'template'\n        ? el.if && isLegacySyntax\n          ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n          : genChildren(el, state) || 'undefined'\n        : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n  }\n\n  function genChildren (\n    el,\n    state,\n    checkSkip,\n    altGenElement,\n    altGenNode\n  ) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot'\n      ) {\n        var normalizationType = checkSkip\n          ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n          : \"\";\n        return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n      }\n      var normalizationType$1 = checkSkip\n        ? getNormalizationType(children, state.maybeComponent)\n        : 0;\n      var gen = altGenNode || genNode;\n      return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType (\n    children,\n    maybeComponent\n  ) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue\n      }\n      if (needsNormalization(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n        res = 2;\n        break\n      }\n      if (maybeComponent(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n        res = 1;\n      }\n    }\n    return res\n  }\n\n  function needsNormalization (el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n  }\n\n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n\n  function genText (text) {\n    return (\"_v(\" + (text.type === 2\n      ? text.expression // no need for () because already wrapped in _s()\n      : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n  }\n\n  function genComment (comment) {\n    return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n  }\n\n  function genSlot (el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n    var attrs = el.attrs || el.dynamicAttrs\n      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n          // slot props are camelized\n          name: camelize(attr.name),\n          value: attr.value,\n          dynamic: attr.dynamic\n        }); }))\n      : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')'\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent (\n    componentName,\n    el,\n    state\n  ) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n  }\n\n  function genProps (props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += (prop.name) + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n    if (dynamicProps) {\n      return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n    } else {\n      return staticProps\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines (text) {\n    return text\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029')\n  }\n\n  /*  */\n\n\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + (\n    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n    'super,throw,while,yield,delete,export,import,return,switch,default,' +\n    'extends,finally,continue,debugger,function,arguments'\n  ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + (\n    'delete,typeof,void'\n  ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors (ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode (node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else {\n              checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent (exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\n        \"avoid using JavaScript unary operator as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n        range\n      );\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor (node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier (\n    ident,\n    type,\n    text,\n    warn,\n    range\n  ) {\n    if (typeof ident === 'string') {\n      try {\n        new Function((\"var \" + ident + \"=_\"));\n      } catch (e) {\n        warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n      }\n    }\n  }\n\n  function checkExpression (exp, text, warn, range) {\n    try {\n      new Function((\"return \" + exp));\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\n          \"avoid using JavaScript keyword as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n          range\n        );\n      } else {\n        warn(\n          \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame (\n    source,\n    start,\n    end\n  ) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) { continue }\n          res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break\n      }\n    }\n    return res.join('\\n')\n  }\n\n  function repeat$1 (str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) { // eslint-disable-line\n        if (n & 1) { result += str; }\n        n >>>= 1;\n        if (n <= 0) { break }\n        str += str;\n      }\n    }\n    return result\n  }\n\n  /*  */\n\n\n\n  function createFunction (code, errors) {\n    try {\n      return new Function(code)\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop\n    }\n  }\n\n  function createCompileToFunctionFn (compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions (\n      template,\n      options,\n      vm\n    ) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1(\n              'It seems you are using the standalone build of Vue.js in an ' +\n              'environment with Content Security Policy that prohibits unsafe-eval. ' +\n              'The template compiler cannot work in this environment. Consider ' +\n              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n              'templates into render functions.'\n            );\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters\n        ? String(options.delimiters) + template\n        : template;\n      if (cache[key]) {\n        return cache[key]\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                generateCodeFrame(template, e.start, e.end),\n                vm\n              );\n            });\n          } else {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n              compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n              vm\n            );\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n          } else {\n            compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors)\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\n            \"Failed to generate render function:\\n\\n\" +\n            fnGenErrors.map(function (ref) {\n              var err = ref.err;\n              var code = ref.code;\n\n              return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n          }).join('\\n'),\n            vm\n          );\n        }\n      }\n\n      return (cache[key] = res)\n    }\n  }\n\n  /*  */\n\n  function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n      function compile (\n        template,\n        options\n      ) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules =\n              (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(\n              Object.create(baseOptions.directives || null),\n              options.directives\n            );\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      }\n    }\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile (\n    template,\n    options\n  ) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    }\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode (href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\n        \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n      );\n      return this\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\n                (\"Template element not found or is empty: \" + (options.template)),\n                this\n              );\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating)\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML (el) {\n    if (el.outerHTML) {\n      return el.outerHTML\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/vue/dist/vue.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","import Vue from 'vue/dist/vue';\nimport snake from './js/components/snake/snake';\n\nvar App = new Vue({\n    el: '#app',\n    data: {}\n})\n\n\n\n// WEBPACK FOOTER //\n// ./resources/assets/App.js","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/timers-browserify/main.js","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/setimmediate/setImmediate.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/process/browser.js","import Vue from \"vue/dist/vue\";\nimport game from './game';\n\nvar snake = Vue.component('snake', {\n    data: function () {\n        return {\n            play: false,\n            score: 0,\n        }\n    },\n    methods: {\n        playToggle() {\n            this.play = !this.play;\n        },\n        onPlayChange(val) {\n            this.play = val;\n        },\n        onScoreChange(val) {\n            this.score = val;\n        }\n    },\n    template: `\n        <div>\n            <div class=\"snake-container\">\n                <div class=\"snake\">\n                    <div class=\"top-bar flex align-vertical-center align-horizontal-space-between\">\n                        <div class=\"score\">\n                            Score: {{score}}\n                        </div>\n                        <div class=\"butons\">\n                            <button v-on:click=\"playToggle\" v-bind:class=\"['button','small', play ? 'pause-button' : 'play-button']\">\n                                <span v-if=\"play\">Pause</span>\n                                <span v-else>Play</span>\n                            </button>\n                        </div>\n                    </div>\n                    <game v-bind:play=\"play\" v-on:onPlayChange=\"onPlayChange\" v-on:onScoreChange=\"onScoreChange\"></game>\n                </div>\n            </div>\n        </div>\n    `\n})\n\nexport default snake;\n\n\n\n// WEBPACK FOOTER //\n// ./resources/assets/js/components/snake/snake.js","import Vue from \"vue/dist/vue\";\nimport config from '../../../config';\n\nvar game = Vue.component('game', {\n    props: {\n        play: {type: Boolean}\n    },\n    data: function () {\n        return {\n            snake: {\n                play: this.play,\n                tail: [],\n                directionX: 1,\n                directionY: 0,\n            },\n            apple: {\n                posX: 0,\n                posY: 0,\n            },\n            score: {\n                count: 0,\n            },\n            timer: null,\n        }\n    },\n    created() {\n        this.boxCountX = config.canvas.width / config.canvas.gridSize;\n        this.boxCountY = config.canvas.height / config.canvas.gridSize;\n\n        this.headOfSnake = Object.assign({}, this.snake.tail[this.snake.tail.length - 1]);\n        this.endOfSnake = Object.assign({}, this.snake.tail[0]);\n    },\n    mounted() {\n        this.createApple();\n        this.createSnake();\n        this.draw();\n        document.addEventListener('keydown', this.onKeyDown);\n    },\n    watch: {\n        play() {\n            this.snake.play = this.play;\n        },\n        'snake.play': function () {\n            this.$emit('onPlayChange', this.snake.play);\n            this.loop();\n        },\n        'score.count': function () {\n            this.$emit('onScoreChange', this.score.count);\n        }\n    },\n    methods: {\n        loop() {\n            clearInterval(this.timer);\n            if (!this.snake.play) {\n                return false;\n            }\n\n            this.timer = setInterval(() => {\n                this.calc();\n                this.draw();\n            }, config.snake.speed);\n        },\n        calc() {\n            this.headOfSnake = Object.assign({}, this.snake.tail[this.snake.tail.length - 1]);\n            this.endOfSnake = Object.assign({}, this.snake.tail[0]);\n\n            this.headOfSnake.posX += this.snake.directionX;\n            this.headOfSnake.posY += this.snake.directionY;\n\n            // Out of box control\n            if (this.headOfSnake.posX === this.boxCountX) {\n                this.headOfSnake.posX = 0;\n            } else if (this.headOfSnake.posX < 0) {\n                this.headOfSnake.posX = this.boxCountX - 1;\n            } else if (this.headOfSnake.posY === this.boxCountY) {\n                this.headOfSnake.posY = 0;\n            } else if (this.headOfSnake.posY < 0) {\n                this.headOfSnake.posY = this.boxCountY - 1;\n            }\n\n            if (this.isEatingAppleSnake()) {\n                this.scoreChange();\n                this.addTailSnake();\n                this.createApple();\n            }\n\n            if (this.isBumpSnake()) {\n                this.gameReset();\n                return;\n            }\n\n            this.snake.tail.push(this.headOfSnake);\n            this.snake.tail.shift();\n        },\n        draw() {\n            const canvas = this.$refs.canvas;\n            const context = canvas.getContext('2d');\n            this.drawCanvas(canvas, context);\n            this.drawApple(context);\n            this.drawSnake(context);\n        },\n        drawCanvas(canvas, context) {\n            canvas.width = config.canvas.width;\n            canvas.height = config.canvas.height;\n\n            context.fillStyle = 'black';\n            context.fillRect(\n                0,\n                0,\n                config.canvas.width,\n                config.canvas.height\n            );\n        },\n        createApple() {\n            this.apple.posX = Math.floor(Math.random() * this.boxCountX);\n            this.apple.posY = Math.floor(Math.random() * this.boxCountY);\n        },\n        drawApple(context) {\n            context.fillStyle = config.apple.color;\n            context.fillRect(\n                this.apple.posX * config.canvas.gridSize,\n                this.apple.posY * config.canvas.gridSize,\n                config.canvas.gridSize - config.canvas.gridSpace,\n                config.canvas.gridSize - config.canvas.gridSpace\n            );\n        },\n        createSnake() {\n            let position = Math.floor(Math.random() * (this.boxCountX - (config.snake.initialTailSize * 3))) + config.snake.initialTailSize;\n            this.snake.tail = [];\n            for (let i = 0; i <= config.snake.initialTailSize; i++) {\n                this.snake.tail.push({\n                    posX: this.snake.directionX ? position + i : position,\n                    posY: this.snake.directionY ? position + i : position,\n                });\n            }\n        },\n        addTailSnake() {\n            this.endOfSnake.posX += this.snake.directionX;\n            this.endOfSnake.posY += this.snake.directionY;\n            this.snake.tail.unshift(this.endOfSnake);\n        },\n        isEatingAppleSnake() {\n            if (this.headOfSnake.posX === this.apple.posX && this.headOfSnake.posY === this.apple.posY) {\n                return true;\n            }\n            return false;\n        },\n        isBumpSnake() {\n            for (let i in this.snake.tail) {\n                if (this.snake.tail[i].posX === this.headOfSnake.posX && this.snake.tail[i].posY === this.headOfSnake.posY) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        drawSnake(context) {\n            this.snake.tail.forEach(tail => {\n                context.fillStyle = config.snake.color;\n                context.fillRect(\n                    tail.posX * config.canvas.gridSize,\n                    tail.posY * config.canvas.gridSize,\n                    config.canvas.gridSize - config.canvas.gridSpace,\n                    config.canvas.gridSize - config.canvas.gridSpace\n                );\n            });\n        },\n        gamePlay() {\n            this.snake.play = true;\n        },\n        gamePause() {\n            this.snake.play = false;\n        },\n        gameReset() {\n            this.score.count = 0;\n            this.gamePause();\n            this.createSnake();\n            this.createApple();\n            this.draw();\n        },\n        scoreChange(count = 1) {\n            this.score.count += count;\n        },\n        onKeyDown(e) {\n            // Direction keys\n            if (config.keys.left.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateLeft();\n            }\n            if (config.keys.up.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateUp();\n            }\n            if (config.keys.right.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateRight();\n            }\n            if (config.keys.down.indexOf(e.keyCode) !== -1) {\n                this.snakeRotateDown();\n            }\n            // Play\n            if (config.keys.gamePlay.indexOf(e.keyCode) !== -1) {\n                this.gamePlay();\n            }\n            // Play Toggle\n            if (config.keys.gamePlayToggle.indexOf(e.keyCode) !== -1) {\n                this.snake.play ? this.gamePause() : this.gamePlay();\n            }\n        },\n        snakeRotateLeft() {\n            if (this.snake.directionX !== 1) {\n                this.snake.directionX = -1;\n                this.snake.directionY = 0;\n            }\n        },\n        snakeRotateUp() {\n            if (this.snake.directionY !== 1) {\n                this.snake.directionY = -1;\n                this.snake.directionX = 0;\n            }\n        },\n        snakeRotateRight() {\n            if (this.snake.directionX !== -1) {\n                this.snake.directionX = 1;\n                this.snake.directionY = 0;\n            }\n        },\n        snakeRotateDown() {\n            if (this.snake.directionY !== -1) {\n                this.snake.directionY = 1;\n                this.snake.directionX = 0;\n            }\n        },\n    },\n    template: `\n        <canvas ref=\"canvas\"></canvas>\n    `,\n})\n\nexport default game;\n\n\n\n// WEBPACK FOOTER //\n// ./resources/assets/js/components/snake/game.js","var config = {\n    canvas: {\n        width: 900,\n        height: 700,\n        gridSize: 20,\n        gridSpace: 2,\n    },\n    snake: {\n        color: '#fff',\n        speed: 1000 / 15,\n        initialTailSize: 9,\n    },\n    apple : {\n        color: 'red',\n    },\n    keys : {\n        left: [37, 65],\n        up: [38, 87],\n        right: [39, 68],\n        down: [40, 83],\n        get gamePlay() {\n            return [].concat(this.left, this.up, this.right, this.down)\n        },\n        gamePlayToggle: [32],\n    }\n}\n\nexport default config;\n\n\n\n\n// WEBPACK FOOTER //\n// ./resources/assets/config.js"],"sourceRoot":""}